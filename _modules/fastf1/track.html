

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>fastf1.track &mdash; Fast F1  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Fast F1
          

          
          </a>

          
            
            
              <div class="version">
                2.1-rc
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/theOehrly/Fast-F1">← Back to Github</a></li>
</ul>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fastf1.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fastf1.html#getting-started">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fastf1.html#package-functions">Package functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.core</span></code> - Core module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.api</span></code> - Api module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.utils</span></code> - Utils module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plotting.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.plotting</span></code> - Plotting module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../legacy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.legacy</span></code> - Provides access to legacy functionality</a></li>
</ul>
<p class="caption"><span class="caption-text">Information:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../time_explanation.html">Time, Date and Timing - Explanation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../time_explanation.html#points-in-time">Points in Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../time_explanation.html#lap-timing">Lap timing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../howto_accurate_calculations.html">How to perform calculations accurately</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../howto_accurate_calculations.html#validating-results">Validating results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../howto_accurate_calculations.html#working-with-the-available-data">Working with the available data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../howto_accurate_calculations.html#slicing-data-by-lap-for-use-in-further-calculations">Slicing data by lap for use in further calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../howto_accurate_calculations.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../known_bugs.html">Known bugs and caveats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../troubleshooting.html#something-doesn-t-work">Something doesn’t work</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-1-refactoring-accuracy-improvements-and-a-more-accessible-interface">v2.1: Refactoring, accuracy improvements and a more accessible interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-0-2-api-code-overhaul">v2.0.2: API code overhaul</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-0-1-integration-of-a-newer-version-of-ax6-s-old-repository">v2.0.1: Integration of a newer version of Ax6’s old repository</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-0-0-first-release-of-this-fork">v2.0.0: first release of this fork</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v1-5-1-last-release-by-ax6">v1.5.1: last release by Ax6</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Fast F1</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>fastf1.track</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for fastf1.track</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:mod:`fastf1.track` - Track module</span>
<span class="sd">==================================</span>

<span class="sd">.. warning::</span>
<span class="sd">    This module is currently broken!</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">fastf1.func</span> <span class="kn">import</span> <span class="n">min_index</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Distinction between &quot;Time&quot; and &quot;Date&quot;:</span>

<span class="sd">Time:   A time stamp counting up from the start of the session.</span>
<span class="sd">        Might sometimes be called session time for sake of clarity.</span>
<span class="sd">        Format: HH:MM:SS.000</span>

<span class="sd">Date:   The actual date and time at which something happened.</span>
<span class="sd">        Timezone is UTC I think.</span>
<span class="sd">        Format: YYYY-MM-DD HH:MM:SS.000</span>

<span class="sd">The terms time and date will be used consistently with this meaning.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="TrackPoint"><a class="viewcode-back" href="../../track.html#fastf1.track.TrackPoint">[docs]</a><span class="k">class</span> <span class="nc">TrackPoint</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Simple point class.</span>

<span class="sd">    A point has an x and y coordinate and an optional date.</span>
<span class="sd">    A function for calculating the square of the distance to another point is also provided.</span>

<span class="sd">    For convenience reasons point.x and point.y can also be accessed as point[&#39;x&#39;] and point[&#39;y&#39;] (get only).</span>
<span class="sd">    Only use this implementation when necessary because it lacks clarity. It&#39;s not quite obvious then that poitn is a</span>
<span class="sd">    separate class (could be a dictionary for example)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param x: x coordinate</span>
<span class="sd">        :type x: int or float</span>
<span class="sd">        :param y: y coordinate</span>
<span class="sd">        :type y: int or float</span>
<span class="sd">        :param date: optional: A pandas datetime (compatible) object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">date</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span>

<div class="viewcode-block" id="TrackPoint.get_sqr_dist"><a class="viewcode-back" href="../../track.html#fastf1.track.TrackPoint.get_sqr_dist">[docs]</a>    <span class="k">def</span> <span class="nf">get_sqr_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the square of the distance to another point.</span>

<span class="sd">        :param other: Another point</span>
<span class="sd">        :type other: TrackPoint</span>
<span class="sd">        :return: distance^2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dist</span></div></div>


<div class="viewcode-block" id="Track"><a class="viewcode-back" href="../../track.html#fastf1.track.Track">[docs]</a><span class="k">class</span> <span class="nc">Track</span><span class="p">:</span>
    <span class="c1"># TODO reorder points when start finish line position is known</span>
    <span class="sd">&quot;&quot;&quot;Track position related data processing.</span>

<span class="sd">    The unit (if any) of F1&#39;s coordinate system is unknown to me. Approx.: value / 3,61 = value in meters</span>

<span class="sd">    Although there are more than one hundred thousand points of position data per session, the number of</span>
<span class="sd">    unique points on track is limited. Typically there is about one unique point per meter of track length.</span>
<span class="sd">    This does not mean that the points have a fixed distance though. In slow corners they are closer together than</span>
<span class="sd">    on straights. A typical track has between 5000 and 7000 unique points.</span>
<span class="sd">    When generating the track map, all duplicate points are removed from the raw data so that only unique points are left.</span>
<span class="sd">    Then those points are sorted into the correct order.</span>
<span class="sd">    Not all unique points of a given track are necessarily present in each session. There is simply a chance that position</span>
<span class="sd">    data from no car is ever sent from a point. In this case we can&#39;t know that this point exist.</span>
<span class="sd">    This is not a problem, but the following needs to be kept in mind:</span>

<span class="sd">    The track class and its track map are only a valid representation of the data they were calculated from.</span>
<span class="sd">    E.g. do not use a track map for race data when it was calculated from qualifying data.</span>

<span class="sd">    Sharing a track map between multiple sessions may be possible if the all points from all of these</span>
<span class="sd">    sessions where joined before and the track map was therefore calculated from both sessions at the same time.</span>
<span class="sd">    Although this may be possible, it is neither tested, nor intended, recommended or implemented (yet). If consistency</span>
<span class="sd">    of position data between sessions can be validated, this might be a way of getting more data and thereby increased accuracy of</span>
<span class="sd">    some statistically computed values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_frame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new track map object.</span>

<span class="sd">        :param pos_frame: Dictionary containing a pandas.DataFrame with position data per car (as returned by fastf1.api.position)</span>
<span class="sd">        :type pos_frame: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span> <span class="o">=</span> <span class="n">pos_frame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unsorted_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excluded_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sorted_x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># list of sorted coordinates for easy plotting and lazy coordinate validation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted_y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finish_line</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distances_normalized</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vis_freq</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vis_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># extract point from position data frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsorted_points_from_pos_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_unsorted_points_from_pos_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract all unique track points from the position data.&quot;&quot;&quot;</span>
        <span class="c1"># get all driver numbers</span>
        <span class="n">drivers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># create a combined data frame with all column names but without data; use the data of the first driver to get the column names</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">[</span><span class="n">drivers</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span><span class="p">])</span>

        <span class="c1"># add the data of all drivers</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">drivers</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="c1"># filter out data points where the car is not on track</span>
        <span class="n">is_on_track</span> <span class="o">=</span> <span class="n">combined</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;OnTrack&#39;</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">combined</span><span class="p">[</span><span class="n">is_on_track</span><span class="p">]</span>

        <span class="c1"># filter out anything but X and Y coordinates and drop duplicate values</span>
        <span class="n">no_dupl_combined</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>

        <span class="c1"># create a point object for each point</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">no_dupl_combined</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unsorted_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TrackPoint</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_init_viusualization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initiate the plot for visualizing the progress of sorting the track points.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vis_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line2</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((),</span> <span class="p">(),</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line1</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((),</span> <span class="p">(),</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cleanup_visualization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clean up the sorting visualization plot and &#39;reset&#39; matplotlib so following plots are not influenced.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_visualize_sorting_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Visualize the current progress of sorting of the track points.</span>

<span class="sd">        Updates the plot with the current data. The plot is created first if this is</span>
<span class="sd">        the first call to this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis_freq</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># don&#39;t do visualization if _vis_freq is zero</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_viusualization</span><span class="p">()</span>  <span class="c1"># first call, setup the plot</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vis_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis_counter</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># visualize current state</span>
            <span class="n">xvals_sorted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">yvals_sorted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">:</span>
                <span class="n">xvals_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">yvals_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

            <span class="n">xvals_unsorted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">yvals_unsorted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsorted_points</span><span class="p">:</span>
                <span class="n">xvals_unsorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">yvals_unsorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

            <span class="c1"># update plot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_line1</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">xvals_sorted</span><span class="p">,</span> <span class="n">yvals_sorted</span><span class="p">)</span>  <span class="c1"># set plot data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_line2</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">xvals_unsorted</span><span class="p">,</span> <span class="n">yvals_unsorted</span><span class="p">)</span>  <span class="c1"># set plot data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">relim</span><span class="p">()</span>  <span class="c1"># recompute the data limits</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>  <span class="c1"># automatic axis scaling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_integrate_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integrate distance over all points and save distance from start/finish line for each point.&quot;&quot;&quot;</span>
        <span class="c1"># TODO this is currently not implemented; need start/finish line position and direction. Maybe then save results per point in point object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># distance is obviously zero at the starting point</span>

        <span class="n">distance_covered</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># distance since first point</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">)):</span>
            <span class="c1"># calculate the length of the segment between the last and the current point</span>
            <span class="n">segment_length</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_sqr_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">distance_covered</span> <span class="o">+=</span> <span class="n">segment_length</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_covered</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distances_normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_determine_track_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the track direction is correct and if not reverse the list of sorted points to correct it.</span>

<span class="sd">        This is done by getting two arbitrary points from the position (telemetry) data. Then it is checked that the first</span>
<span class="sd">        of these two points is also first in the list of sorted points. If not, the list is reversed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">drivers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">drv</span> <span class="o">=</span> <span class="n">drivers</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="c1"># select a driver</span>
            <span class="n">on_track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">[</span><span class="n">drv</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">Status</span> <span class="o">==</span> <span class="s2">&quot;OnTrack&quot;</span><span class="p">]</span>  <span class="c1"># use 2nd lap as a sample lap</span>

            <span class="k">if</span> <span class="n">on_track</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># this driver was never on track; try the next driver</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">on_track</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>  <span class="c1"># get two points; doesn&#39;t really matter which points are used</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">on_track</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">101</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># driver wasn&#39;t on track very long apparently; try the next driver</span>
                <span class="k">continue</span>

            <span class="n">point1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_point</span><span class="p">(</span><span class="n">TrackPoint</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">Y</span><span class="p">))</span>  <span class="c1"># the resulting point will have the same coordinates but the exact instance</span>
            <span class="n">point2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_point</span><span class="p">(</span><span class="n">TrackPoint</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">Y</span><span class="p">))</span>  <span class="c1"># is required to get its index in the next step</span>

            <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span>
            <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">point2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">idx1</span> <span class="o">&gt;</span> <span class="n">idx2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">idx1</span> <span class="o">-</span> <span class="n">idx2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">):</span>
                <span class="c1"># first part of this check: The point with the higher index is the one which is later in the lap. This should be the second point.</span>
                <span class="c1">#                           If this is not the case, the list needs to be reversed.</span>
                <span class="c1"># second part: The exception is, if the list divides the track between these two points. In this case the first point would have</span>
                <span class="c1">#               a higher index because it right at the end of the list while the second point is at the beginning. In case that</span>
                <span class="c1">#               more than 90% of the list are between these two points this edge case is assumed. The list will not be reversed.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

            <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_sort_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Does the actual sorting of points.&quot;&quot;&quot;</span>
        <span class="c1"># Get the first point as a starting point. Any point could be used as starting point. Later the next closest point is used as next point.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsorted_points</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsorted_points</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_visualize_sorting_progress</span><span class="p">()</span>

            <span class="c1"># calculate all distances between the next point and all other points</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsorted_points</span><span class="p">:</span>
                <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span><span class="o">.</span><span class="n">get_sqr_dist</span><span class="p">(</span><span class="n">pnt</span><span class="p">))</span>

            <span class="c1"># get the next closest point and its index</span>
            <span class="n">min_dst</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">index_min</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">min_dst</span><span class="p">)</span>

            <span class="c1"># Check if the closest point is within a reasonable distance. There are some outliers which are very clearly not on track.</span>
            <span class="c1"># The limit value was determined experimentally. Usually the distance between to points is approx. 100.</span>
            <span class="c1"># (This is the square of the distance. Not the distance itself.)</span>
            <span class="c1"># If the _next_point has no other point within a reasonable distance, it is considered an outlier and removed.</span>
            <span class="k">if</span> <span class="n">min_dst</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">excluded_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span><span class="p">)</span>

            <span class="c1"># Get a new _next_point. The new point is the one which was closest to the last one.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsorted_points</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index_min</span><span class="p">)</span>

        <span class="c1"># append the last point if it is not an outlier</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span><span class="o">.</span><span class="n">get_sqr_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">200</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">excluded_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_point</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_visualization</span><span class="p">()</span>

<div class="viewcode-block" id="Track.set_finish_line"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.set_finish_line">[docs]</a>    <span class="k">def</span> <span class="nf">set_finish_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set coordinates for the finish line position.</span>

<span class="sd">        Internally the next closest unique track point will be used!</span>

<span class="sd">        :param x: coordinate x</span>
<span class="sd">        :type x: int or float</span>
<span class="sd">        :param y: coordinate y</span>
<span class="sd">        :type y: int or float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_point</span><span class="p">(</span><span class="n">TrackPoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_line</span> <span class="o">=</span> <span class="n">point</span></div>

<div class="viewcode-block" id="Track.resync_lap_times"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.resync_lap_times">[docs]</a>    <span class="k">def</span> <span class="nf">resync_lap_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laps_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Synchronize the lap data to the set finish line position.</span>

<span class="sd">        A new column &#39;Date&#39; will be added to the DataFrame. The original values in &#39;Time&#39;</span>
<span class="sd">        will be left unchanged. The values in &#39;Date&#39; are synchronized with telemetry and</span>
<span class="sd">        position data IF the finish line position is correct.</span>

<span class="sd">        :param laps_data: DataFrame containing lap data as returned by api.timing_data</span>
<span class="sd">        :type laps_data: pandas.DataFrame</span>
<span class="sd">        :returns: The original Data Frame with a new column &#39;Date&#39;&quot;&quot;&quot;</span>
        <span class="n">drivers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># calculate the start date of the session</span>
        <span class="n">some_driver</span> <span class="o">=</span> <span class="n">drivers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># TODO to be sure this should be done with multiple drivers</span>
        <span class="n">session_start_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">[</span><span class="n">some_driver</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Date</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>

        <span class="n">dates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">lap</span> <span class="ow">in</span> <span class="n">laps_data</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">approx_lap_end_date</span> <span class="o">=</span> <span class="n">session_start_date</span> <span class="o">+</span> <span class="n">lap</span><span class="o">.</span><span class="n">Time</span>

            <span class="n">range_start</span> <span class="o">=</span> <span class="n">approx_lap_end_date</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
            <span class="n">range_end</span> <span class="o">=</span> <span class="n">approx_lap_end_date</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lap</span><span class="o">.</span><span class="n">Driver</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">dates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_time_from_pos</span><span class="p">(</span><span class="n">lap</span><span class="o">.</span><span class="n">Driver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish_line</span><span class="p">,</span> <span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="p">)</span>
            <span class="n">dates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>

        <span class="c1"># create a copy of the data frame because insert works inplace and I think that&#39;s not intuitive here</span>
        <span class="n">laps_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">laps_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">laps_data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="n">dates</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">laps_data</span></div>

<div class="viewcode-block" id="Track.generate_track"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.generate_track">[docs]</a>    <span class="k">def</span> <span class="nf">generate_track</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visualization_frequency</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a track map from the raw points.</span>

<span class="sd">        Sorts all points. Then determines the correct direction and starting point (both not implemented yet).</span>
<span class="sd">        Finally the lap distance is calculated by integrating over all points (implemented partially, not enabled, depending on previous).</span>
<span class="sd">        The distance since start is saved for each point. Additionally, the lap distance is saved normalized to a range of 0 to 1.</span>
<span class="sd">        :param visualization_frequency: (optional) specify  after how many calculated points the plot should be updated.</span>
<span class="sd">        Set to zero for never (default: never). Plotting is somewhat slow. A visualization frequency greater than 50 is recommended.</span>
<span class="sd">        :type visualization_frequency: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vis_freq</span> <span class="o">=</span> <span class="n">visualization_frequency</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sort_points</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_determine_track_direction</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sorted_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sorted_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></div>

        <span class="c1"># self._integrate_distance()  # TODO this should not be done before determining track direction and start/finish line position</span>

        <span class="c1"># xvals = list()  # TODO rethink this</span>
        <span class="c1"># yvals = list()</span>
        <span class="c1"># for point in self.sorted_points:</span>
        <span class="c1">#     xvals.append(point.x)</span>
        <span class="c1">#     yvals.append(point.y)</span>
        <span class="c1">#</span>
        <span class="c1"># self.track = pd.DataFrame({&#39;X&#39;: xvals,</span>
        <span class="c1">#                            &#39;Y&#39;: yvals,</span>
        <span class="c1">#                            &#39;Distance&#39;: self.distances,</span>
        <span class="c1">#                            &#39;Normalized&#39;: self.distances_normalized})</span>

<div class="viewcode-block" id="Track.lazy_is_track_point"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.lazy_is_track_point">[docs]</a>    <span class="k">def</span> <span class="nf">lazy_is_track_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lazy check for whether two coordinates are the coordinates of a unique track point.</span>

<span class="sd">        This function only checks both coordinates independently. But it does not verify that the</span>
<span class="sd">        combination of both coordinates is a valid unique track point (therefore &quot;lazy&quot; check).</span>
<span class="sd">        This is an intentional measure for saving time.</span>

<span class="sd">        :param x: x coordinate</span>
<span class="sd">        :type x: int or float</span>
<span class="sd">        :param y: x coordinate</span>
<span class="sd">        :type y: int or float</span>
<span class="sd">        :return: True or False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_x</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_y</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Track.direction_to_point"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.direction_to_point">[docs]</a>    <span class="k">def</span> <span class="nf">direction_to_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_point</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">rel_max</span><span class="o">=</span><span class="mf">0.49</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if a point is behind or in front of a reference point on track.</span>

<span class="sd">        Do not use this function in long iterations as it is comparably slow!</span>

<span class="sd">        :param ref_point: The reference point</span>
<span class="sd">        :type ref_point: TrackPoint</span>
<span class="sd">        :param other: The second point</span>
<span class="sd">        :type other: TrackPoint</span>
<span class="sd">        :param rel_max: (optional) maximum relative distance on track for checking if the point is before or after.</span>
<span class="sd">            If a value is more than this relative distance away zero is returned. Distance is measured in points here which is</span>
<span class="sd">            exactly equal to actual distance here.</span>
<span class="sd">            This value needs to be 0.49 or smaller. (Default is 0.49)</span>
<span class="sd">        :return: -1 -&gt; behind; 1 -&gt; in front; 0 -&gt; outside of max relative distance or could not be determined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_point</span><span class="p">(</span><span class="n">ref_point</span><span class="p">)</span>  <span class="c1"># get the closest unique track points</span>
        <span class="n">other_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_point</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="n">ref_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ref_u</span><span class="p">)</span>  <span class="c1"># get the indices for the unique points</span>
        <span class="n">other_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">other_u</span><span class="p">)</span>
        <span class="n">delta_i</span> <span class="o">=</span> <span class="n">other_i</span> <span class="o">-</span> <span class="n">ref_i</span>

        <span class="k">if</span> <span class="n">delta_i</span> <span class="o">&lt;</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rel_max</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>  <span class="c1"># edge case; point is before but the end of the list is in between</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rel_max</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># point is too far away</span>

        <span class="k">if</span> <span class="n">delta_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>  <span class="c1"># point is in front</span>

        <span class="k">elif</span> <span class="n">delta_i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># point is behind</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># point is so close that the unique points are the same</span>
            <span class="c1"># check based on vector direction from point to point; for very short distances (like here) this is a sufficient criteria.</span>
            <span class="c1"># For longer distances this is not even a necessary criteria though!</span>
            <span class="n">dx_q</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">ref_point</span><span class="o">.</span><span class="n">x</span>  <span class="c1"># (dx_q, dy_q) form the vector from ref to other (q for query)</span>
            <span class="n">dy_q</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ref_point</span><span class="o">.</span><span class="n">y</span>

            <span class="k">if</span> <span class="n">ref_i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">):</span>  <span class="c1"># get the next point (with edge case handling for current point is last point in list)</span>
                <span class="n">next_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[</span><span class="n">ref_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">dx_t</span> <span class="o">=</span> <span class="n">next_u</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">ref_u</span><span class="o">.</span><span class="n">x</span>  <span class="c1"># (dx_t, dy_t) form the vector from unique ref to next on track (t for track)</span>
            <span class="n">dy_t</span> <span class="o">=</span> <span class="n">next_u</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ref_u</span><span class="o">.</span><span class="n">y</span>

            <span class="c1"># test if the vectors point in the same direction by calculating the dot product</span>
            <span class="c1"># the dot product is greater than zero if the angle between the vectors is less than 90 degree</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">dx_q</span> <span class="o">*</span> <span class="n">dx_t</span> <span class="o">+</span> <span class="n">dy_q</span> <span class="o">*</span> <span class="n">dy_t</span>
            <span class="k">if</span> <span class="n">dp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">dp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Track.get_closest_point"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.get_closest_point">[docs]</a>    <span class="k">def</span> <span class="nf">get_closest_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the closest unique track point to any given point.</span>

<span class="sd">        &#39;point&#39; can be an arbitrary point anywhere. If &#39;point&#39; is one of the unique track points</span>
<span class="sd">        the same point will be returned as no point is closer to it than itself.</span>

<span class="sd">        This function assumes that the track is made up of all possible points.</span>
<span class="sd">        This assumption is valid within the scope of the data from which the track was calculated.</span>
<span class="sd">        See disclaimer for track map class in general</span>

<span class="sd">        :param point: A point with arbitrary coordinates</span>
<span class="sd">        :type point: TrackPoint</span>
<span class="sd">        :return: A single TrackPoint</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">distances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">track_point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">:</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">track_point</span><span class="o">.</span><span class="n">get_sqr_dist</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[</span><span class="n">distances</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">distances</span><span class="p">))]</span></div>

<div class="viewcode-block" id="Track.get_points_between"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.get_points_between">[docs]</a>    <span class="k">def</span> <span class="nf">get_points_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">,</span> <span class="n">short</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all unique track points between two points.</span>

<span class="sd">        &#39;point1&#39; and &#39;point2&#39; must be unique track points. The cannot be points with random coordinates.</span>
<span class="sd">        If you want to use any given point, call .get_closest_point() first to get the unique track point</span>
<span class="sd">        which is closest to your point. You can then pass it as reference point to this function.</span>

<span class="sd">        :param point1: First boundary point</span>
<span class="sd">        :type point1: TrackPoint</span>
<span class="sd">        :param point2: Second boundary point</span>
<span class="sd">        :type point2: TrackPoint</span>
<span class="sd">        :param short: Whether you want to have the result going the long or the short distance between the boundary points.</span>
<span class="sd">        :param include_ref: Whether to include the given boundary points in the returned list of points</span>
<span class="sd">        :return: List of TrackPoints</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">point2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i1</span> <span class="o">-</span> <span class="n">i2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">):</span>
            <span class="n">short_is_inner</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">short_is_inner</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">short</span> <span class="ow">and</span> <span class="n">short_is_inner</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">short</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">short_is_inner</span><span class="p">):</span>
            <span class="c1"># the easy way, simply slice between the two indices</span>
            <span class="n">pnt_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">include_ref</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="n">i2</span><span class="p">:</span>
                    <span class="n">pnt_range</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">point1</span><span class="p">)</span>
                    <span class="n">pnt_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pnt_range</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>
                    <span class="n">pnt_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the harder way; we need the first and last part of the list but not the middle</span>
            <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)]</span>
            <span class="n">second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_points</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># add the reference points correctly</span>
            <span class="c1"># also reverse if necessary to keep a consistent returned order. the first reference point should also be first in the result</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="o">&gt;</span> <span class="n">i2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">include_ref</span><span class="p">:</span>
                    <span class="n">second</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">point1</span><span class="p">)</span>
                    <span class="n">first</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point2</span><span class="p">)</span>
                <span class="n">pnt_range</span> <span class="o">=</span> <span class="n">second</span> <span class="o">+</span> <span class="n">first</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">include_ref</span><span class="p">:</span>
                    <span class="n">second</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>
                    <span class="n">first</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span>
                <span class="n">pnt_range</span> <span class="o">=</span> <span class="n">second</span> <span class="o">+</span> <span class="n">first</span>
                <span class="n">pnt_range</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">pnt_range</span></div>

<div class="viewcode-block" id="Track.get_second_coord"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.get_second_coord">[docs]</a>    <span class="k">def</span> <span class="nf">get_second_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ref_point_1</span><span class="p">,</span> <span class="n">ref_point_2</span><span class="p">,</span> <span class="n">from_coord</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the second coordinate if either x or y are known.</span>

<span class="sd">        The known coordinate does not need to be the coordinate of a unique track point. The result</span>
<span class="sd">        will be interpolated.</span>
<span class="sd">        This requires two reference points between which the point your interested in is located.</span>
<span class="sd">        This is somewhat unstable. If the range between the two points is to long, there might be</span>
<span class="sd">        multiple possible results for your value. In this case this function will fail silently!</span>
<span class="sd">        One of the results will be returned.</span>
<span class="sd">        The track between the two given points should be approximtely straight for this function to</span>
<span class="sd">        work correctly. If the value you&#39;re interested in is in a corner, the corner segment between</span>
<span class="sd">        ref_point_1 and ref_point_2 should be sufficiently short.</span>
<span class="sd">        The reference points need to be unique track points.</span>

<span class="sd">        :param val: known x or y coordinate</span>
<span class="sd">        :type val: int or float</span>
<span class="sd">        :param ref_point_1: First boundary point</span>
<span class="sd">        :type ref_point_1: TrackPoint</span>
<span class="sd">        :param ref_point_2: Second boundary point</span>
<span class="sd">        :type ref_point_2: TrackPoint</span>
<span class="sd">        :param from_coord: Specify whether the given value is the x or y coordinate; one of &#39;x&#39;, &#39;y&#39;</span>
<span class="sd">        :type from_coord: str</span>
<span class="sd">        :return: TrackPoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points_between</span><span class="p">(</span><span class="n">ref_point_1</span><span class="p">,</span> <span class="n">ref_point_2</span><span class="p">)</span>

        <span class="c1"># find the closest point in this range; only valid if the range is approximately straight</span>
        <span class="c1"># because we&#39;re only checking against one coordinate</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_range</span><span class="p">:</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">from_coord</span><span class="p">]</span> <span class="o">-</span> <span class="n">val</span><span class="p">))</span>

        <span class="n">min_i</span> <span class="o">=</span> <span class="n">min_index</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
        <span class="n">p_a</span> <span class="o">=</span> <span class="n">p_range</span><span class="p">[</span><span class="n">min_index</span><span class="p">(</span><span class="n">distances</span><span class="p">)]</span>  <span class="c1"># closest point</span>
        <span class="c1"># second closest point (with edge cases if closest point is first or last point in list)</span>
        <span class="c1"># This works because the points returned by get_points_between() are sorted. The second</span>
        <span class="c1"># closest point therefore needs to be the one before or after the closest point.</span>
        <span class="k">if</span> <span class="n">min_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p_b</span> <span class="o">=</span> <span class="n">p_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">p_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">min_i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">p_b</span> <span class="o">=</span> <span class="n">p_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="n">p_range</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_b</span> <span class="o">=</span> <span class="n">p_range</span><span class="p">[</span><span class="n">min_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">min_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">min_i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">p_range</span><span class="p">[</span><span class="n">min_i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># do interpolation</span>
        <span class="n">delta_x</span> <span class="o">=</span> <span class="n">p_b</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">x</span>
        <span class="n">delta_y</span> <span class="o">=</span> <span class="n">p_b</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">y</span>

        <span class="k">if</span> <span class="n">from_coord</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">interp_delta_x</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">x</span>
            <span class="n">interp_y</span> <span class="o">=</span> <span class="n">p_a</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">delta_y</span> <span class="o">*</span> <span class="n">interp_delta_x</span> <span class="o">/</span> <span class="n">delta_x</span>
            <span class="k">return</span> <span class="n">TrackPoint</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">interp_y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interp_delta_y</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">y</span>
            <span class="n">interp_x</span> <span class="o">=</span> <span class="n">p_a</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">delta_x</span> <span class="o">*</span> <span class="n">interp_delta_y</span> <span class="o">/</span> <span class="n">delta_y</span>
            <span class="k">return</span> <span class="n">TrackPoint</span><span class="p">(</span><span class="n">interp_x</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>

<div class="viewcode-block" id="Track.get_time_from_pos"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.get_time_from_pos">[docs]</a>    <span class="k">def</span> <span class="nf">get_time_from_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">time_range_start</span><span class="p">,</span> <span class="n">time_range_end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the time at which a driver was at a specific coordinate.</span>

<span class="sd">        The point can be any point. It does not need to be a unique track point.</span>
<span class="sd">        A time range needs to be specified because of course a driver passes all parts of the track</span>
<span class="sd">        once every lap (surprise there...). The specified time range should therefore be no longer</span>
<span class="sd">        than one lap so that there are not multiple possible solutions.</span>
<span class="sd">        But shorter is faster in terms of calculating the result. So keep it as short as possible.</span>
<span class="sd">        :param drv: Number of the driver as a string</span>
<span class="sd">        :type drv: str</span>
<span class="sd">        :param point: The point you&#39;re interested in</span>
<span class="sd">        :type point: TrackPoint</span>
<span class="sd">        :param time_range_start: A pandas.Timestamp compatible date</span>
<span class="sd">        :param time_range_end: A pandas.Timestamp compatible date</span>
<span class="sd">        :return: pandas.Timestamp or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;@time_range_start &lt; Date &lt; @time_range_end&quot;</span><span class="p">)</span>  <span class="c1"># get DataFrame for driver</span>

        <span class="n">dists_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pos</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">pnt</span> <span class="o">=</span> <span class="n">TrackPoint</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">Date</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">get_sqr_dist</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
            <span class="n">dists_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dist</span><span class="p">,</span> <span class="n">pnt</span><span class="p">))</span>

        <span class="n">dists_points</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">itm</span><span class="p">:</span> <span class="n">itm</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># sort the list by first value of each tuple (distance)</span>

        <span class="n">p_a</span> <span class="o">=</span> <span class="n">dists_points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># closest point</span>
        <span class="n">p_b</span> <span class="o">=</span> <span class="n">dists_points</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># second closest point</span>

        <span class="k">if</span> <span class="n">p_a</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p_b</span><span class="o">.</span><span class="n">x</span> <span class="ow">and</span> <span class="n">p_a</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">p_b</span><span class="o">.</span><span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># I have no idea how this is even possible, looks like an error in the data retrieved from the api</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p_a</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p_b</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p_a</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p_b</span><span class="o">.</span><span class="n">y</span><span class="p">):</span>  <span class="c1"># use the one with a bigger delta for higher accuracy</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">p_a</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="p">(</span><span class="n">p_b</span><span class="o">.</span><span class="n">date</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">date</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_b</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">p_a</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="p">(</span><span class="n">p_b</span><span class="o">.</span><span class="n">date</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">date</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_b</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p_a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">date</span></div>

<div class="viewcode-block" id="Track.interpolate_pos_from_time"><a class="viewcode-back" href="../../track.html#fastf1.track.Track.interpolate_pos_from_time">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_pos_from_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">query_date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the position of a driver at any given date.</span>

<span class="sd">        :param drv: The number of the driver as a string</span>
<span class="sd">        :type drv: str</span>
<span class="sd">        :param query_date: The date you&#39;re interested in (pandas.Timestamp compatible)</span>
<span class="sd">        :return: TrackPoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use linear interpolation to determine position at arbitrary time</span>
        <span class="n">drv_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span>  <span class="c1"># get DataFrame for driver</span>

        <span class="n">closest</span> <span class="o">=</span> <span class="n">drv_pos</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">query_date</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]]</span>

        <span class="c1"># verify both points are valid unique track points</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lazy_is_track_point</span><span class="p">(</span><span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lazy_is_track_point</span><span class="p">(</span><span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;Y&#39;</span><span class="p">])):</span>

            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">delta_t</span> <span class="o">=</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span>
        <span class="n">delta_x</span> <span class="o">=</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">delta_y</span> <span class="o">=</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">interp_delta_t</span> <span class="o">=</span> <span class="n">query_date</span> <span class="o">-</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span>

        <span class="n">interp_x</span> <span class="o">=</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta_x</span> <span class="o">*</span> <span class="n">interp_delta_t</span> <span class="o">/</span> <span class="n">delta_t</span>
        <span class="n">interp_y</span> <span class="o">=</span> <span class="n">closest</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta_y</span> <span class="o">*</span> <span class="n">interp_delta_t</span> <span class="o">/</span> <span class="n">delta_t</span>

        <span class="k">return</span> <span class="n">TrackPoint</span><span class="p">(</span><span class="n">interp_x</span><span class="p">,</span> <span class="n">interp_y</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright MIT.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>