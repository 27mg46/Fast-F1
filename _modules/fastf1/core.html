

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>fastf1.core &mdash; Fast F1 2.1.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Fast F1
          

          
          </a>

          
            
            
              <div class="version">
                2.1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/theOehrly/Fast-F1">← Back to Github</a></li>
</ul>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fastf1.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fastf1.html#getting-started">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fastf1.html#package-functions">Package functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.core</span></code> - Core module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../core.html#data-objects">Data Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../core.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../core.html#api-reference">API Reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../core.html#id1">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../core.html#get-session">get_session</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../core.html#get-round">get_round</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../core.html#objects">Objects</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../core.html#weekend">Weekend</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../core.html#session">Session</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../core.html#laps">Laps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../core.html#lap">Lap</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../core.html#telemetry">Telemetry</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../core.html#driver">Driver</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../core.html#exceptions">Exceptions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.api</span></code> - Api module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.utils</span></code> - Utils module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plotting.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.plotting</span></code> - Plotting module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livetiming.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.livetiming</span></code> - Live Timing Client</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../livetiming.html#usage-example">Usage Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../livetiming.html#important-notes">Important Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../livetiming.html#command-line-interface">Command Line Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../livetiming.html#save">Save</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../livetiming.html#extract">Extract</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../livetiming.html#module-fastf1.livetiming.client">Live Timing Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../livetiming.html#module-fastf1.livetiming.data">Live Timing Data Object</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../legacy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.legacy</span></code> - Provides access to legacy functionality</a></li>
</ul>
<p class="caption"><span class="caption-text">Information:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../time_explanation.html">Time, Date and Timing - Explanation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../time_explanation.html#points-in-time">Points in Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../time_explanation.html#lap-timing">Lap timing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../howto_accurate_calculations.html">How to perform calculations accurately</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../howto_accurate_calculations.html#validating-results">Validating results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../howto_accurate_calculations.html#working-with-the-available-data">Working with the available data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../howto_accurate_calculations.html#slicing-data-by-lap-for-use-in-further-calculations">Slicing data by lap for use in further calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../howto_accurate_calculations.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../known_bugs.html">Known bugs and caveats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../troubleshooting.html#something-doesn-t-work">Something doesn’t work</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-1-3-improved-error-handling">v2.1.3 Improved error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-1-2-hotfixes-for-loading-live-timing-data">v2.1.2 Hotfixes for loading live timing data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-1-1-add-support-for-recording-and-using-live-timing-data">v2.1.1 Add support for recording and using live timing data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-1-refactoring-accuracy-improvements-and-a-more-accessible-interface">v2.1: Refactoring, accuracy improvements and a more accessible interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-0-2-api-code-overhaul">v2.0.2: API code overhaul</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-0-1-integration-of-a-newer-version-of-ax6-s-old-repository">v2.0.1: Integration of a newer version of Ax6’s old repository</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v2-0-0-first-release-of-this-fork">v2.0.0: first release of this fork</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v1-5-1-last-release-by-ax6">v1.5.1: last release by Ax6</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Fast F1</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>fastf1.core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for fastf1.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:mod:`fastf1.core` - Core module</span>
<span class="sd">================================</span>

<span class="sd">The Fast-F1 core is a collection of functions and data objects for accessing</span>
<span class="sd">and analyzing F1 timing and telemetry data.</span>

<span class="sd">Data Objects</span>
<span class="sd">------------</span>

<span class="sd">All data is provided through the following data objects:</span>

<span class="sd">    .. autosummary::</span>
<span class="sd">       :nosignatures:</span>

<span class="sd">       Weekend</span>
<span class="sd">       Session</span>
<span class="sd">       Laps</span>
<span class="sd">       Lap</span>
<span class="sd">       Telemetry</span>
<span class="sd">       Driver</span>


<span class="sd">The :class:`Weekend` object holds some generic information about the race</span>
<span class="sd">weekend. Furthermore, :class:`Session` objects for the various sessions of</span>
<span class="sd">a weekend can be created from a :class:`Weekend` object.</span>

<span class="sd">The :class:`Session` object is mainly used as an entry point for loading</span>
<span class="sd">timing data and telemetry data. The :class:`Session` can create a</span>
<span class="sd">:class:`Laps` object which contains all timing, track and session status</span>
<span class="sd">data for a whole session.</span>

<span class="sd">Usually you will be using :func:`get_session` to to get a :class:`Session`</span>
<span class="sd">or :class:`Weekend` object.</span>

<span class="sd">The :class:`Laps` object holds detailed information about multiples laps.</span>

<span class="sd">The :class:`Lap` object holds the same information as :class:`Laps` but only</span>
<span class="sd">for one single lap. When selecting a singel lap from a :class:`Laps` object,</span>
<span class="sd">an object of type :class:`Lap` will be returned.</span>

<span class="sd">Apart from only providing data, the :class:`Laps`, :class:`Lap` and</span>
<span class="sd">:class:`Telemetry` objects implement various methods for selecting and</span>
<span class="sd">analyzing specific parts of the data.</span>


<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">    get_session</span>
<span class="sd">    get_round</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">fastf1</span> <span class="kn">import</span> <span class="n">ergast</span>
<span class="kn">from</span> <span class="nn">fastf1</span> <span class="kn">import</span> <span class="n">api</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Using slow pure-python SequenceMatcher&quot;</span><span class="p">)</span>
    <span class="c1"># suppress that warning, it&#39;s confusing at best here, we don&#39;t need fast sequence matching</span>
    <span class="c1"># and the installation (on windows) some effort</span>
    <span class="kn">from</span> <span class="nn">fuzzywuzzy</span> <span class="kn">import</span> <span class="n">fuzz</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;{&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{module: &lt;8}</span><span class="s2"> </span><span class="si">{levelname: &gt;10}</span><span class="s2"> </span><span class="se">\t</span><span class="si">{message}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">TESTING_LOOKUP</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;2020&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="s1">&#39;2020-02-19&#39;</span><span class="p">,</span> <span class="s1">&#39;2020-02-20&#39;</span><span class="p">,</span> <span class="s1">&#39;2020-02-21&#39;</span><span class="p">],</span>
                           <span class="p">[</span><span class="s1">&#39;2020-02-26&#39;</span><span class="p">,</span> <span class="s1">&#39;2020-02-27&#39;</span><span class="p">,</span> <span class="s1">&#39;2020-02-28&#39;</span><span class="p">]],</span>
                  <span class="s1">&#39;2021&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="s1">&#39;2021-03-12&#39;</span><span class="p">,</span> <span class="s1">&#39;2021-03-13&#39;</span><span class="p">,</span> <span class="s1">&#39;2021-03-14&#39;</span><span class="p">]]}</span>

<span class="n">D_LOOKUP</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">44</span><span class="p">,</span> <span class="s1">&#39;HAM&#39;</span><span class="p">,</span> <span class="s1">&#39;Mercedes&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">77</span><span class="p">,</span> <span class="s1">&#39;BOT&#39;</span><span class="p">,</span> <span class="s1">&#39;Mercedes&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">55</span><span class="p">,</span> <span class="s1">&#39;SAI&#39;</span><span class="p">,</span> <span class="s1">&#39;Ferrari&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;LEC&#39;</span><span class="p">,</span> <span class="s1">&#39;Ferrari&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">33</span><span class="p">,</span> <span class="s1">&#39;VER&#39;</span><span class="p">,</span> <span class="s1">&#39;Red Bull&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;PER&#39;</span><span class="p">,</span> <span class="s1">&#39;Red Bull&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;RIC&#39;</span><span class="p">,</span> <span class="s1">&#39;McLaren&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;NOR&#39;</span><span class="p">,</span> <span class="s1">&#39;McLaren&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;VET&#39;</span><span class="p">,</span> <span class="s1">&#39;Aston Martin&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;STR&#39;</span><span class="p">,</span> <span class="s1">&#39;Aston Martin&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;ALO&#39;</span><span class="p">,</span> <span class="s1">&#39;Alpine&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">31</span><span class="p">,</span> <span class="s1">&#39;OCO&#39;</span><span class="p">,</span> <span class="s1">&#39;Alpine&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">22</span><span class="p">,</span> <span class="s1">&#39;TSU&#39;</span><span class="p">,</span> <span class="s1">&#39;AlphaTauri&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;GAS&#39;</span><span class="p">,</span> <span class="s1">&#39;AlphaTauri&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">47</span><span class="p">,</span> <span class="s1">&#39;MSC&#39;</span><span class="p">,</span> <span class="s1">&#39;Haas F1 Team&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;MAZ&#39;</span><span class="p">,</span> <span class="s1">&#39;Haas F1 Team&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;RAI&#39;</span><span class="p">,</span> <span class="s1">&#39;Alfa Romeo&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">99</span><span class="p">,</span> <span class="s1">&#39;GIO&#39;</span><span class="p">,</span> <span class="s1">&#39;Alfa Romeo&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;LAT&#39;</span><span class="p">,</span> <span class="s1">&#39;Williams&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">63</span><span class="p">,</span> <span class="s1">&#39;RUS&#39;</span><span class="p">,</span> <span class="s1">&#39;Williams&#39;</span><span class="p">]]</span>


<div class="viewcode-block" id="get_session"><a class="viewcode-back" href="../../fastf1.html#fastf1.get_session">[docs]</a><span class="k">def</span> <span class="nf">get_session</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">event</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a :class:`Session` or :class:`Weekend` object based on year,</span>
<span class="sd">    event name and session name.</span>
<span class="sd">    This function will take care of crafting an object</span>
<span class="sd">    corresponding to the requested session.</span>
<span class="sd">    If no session is specified, the full weekend is returned.</span>

<span class="sd">    Examples:</span>

<span class="sd">        Get the second free practice of the first race of 2021::</span>

<span class="sd">            get_session(2021, 1, &#39;FP2&#39;)</span>

<span class="sd">        Get the qualifying of the 2020 Austrian Grand Prix::</span>

<span class="sd">            get_session(2020, &#39;Austria&#39;, &#39;Q&#39;)</span>

<span class="sd">        Get the second day of pre-season testing of 2021::</span>

<span class="sd">            get_session(2021, &#39;testing&#39;, 2)</span>


<span class="sd">    Args:</span>
<span class="sd">        year (number): Session year</span>
<span class="sd">        gp (number or string): Name or weekend number (1: Australia,</span>
<span class="sd">                               ..., 21: Abu Dhabi). If gp is a string,</span>
<span class="sd">                               a fuzzy match will be performed on the</span>
<span class="sd">                               season rounds and the most likely will be</span>
<span class="sd">                               selected.</span>

<span class="sd">                               Some examples that will be correctly</span>
<span class="sd">                               interpreted: &#39;bahrain&#39;, &#39;australia&#39;,</span>
<span class="sd">                               &#39;abudabi&#39;, &#39;monza&#39;.</span>

<span class="sd">                               Pass &#39;testing&#39; to fetch Barcelona winter</span>
<span class="sd">                               tests.</span>

<span class="sd">        event (=None): may be &#39;FP1&#39;, &#39;FP2&#39;, &#39;FP3&#39;, &#39;Q&#39; or &#39;R&#39;, if not</span>
<span class="sd">                       specified you get the full :class:`Weekend`.</span>
<span class="sd">                       If gp is &#39;testing&#39; event is the test day (1 to 6)</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`Weekend` or :class:`Session`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">gp</span> <span class="o">==</span> <span class="s1">&#39;testing&#39;</span><span class="p">:</span>
        <span class="n">pre_season_week</span><span class="p">,</span> <span class="n">event</span> <span class="o">=</span> <span class="n">_get_testing_week_event</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
        <span class="n">weekend</span> <span class="o">=</span> <span class="n">Weekend</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">pre_season_week</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="n">weekend</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">get_round</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">gp</span><span class="p">)</span>
    <span class="n">weekend</span> <span class="o">=</span> <span class="n">Weekend</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">gp</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="n">weekend</span><span class="p">,</span> <span class="s1">&#39;Race&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;Q&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="n">weekend</span><span class="p">,</span> <span class="s1">&#39;Qualifying&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;FP3&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="n">weekend</span><span class="p">,</span> <span class="s1">&#39;Practice 3&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;FP2&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="n">weekend</span><span class="p">,</span> <span class="s1">&#39;Practice 2&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;FP1&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="n">weekend</span><span class="p">,</span> <span class="s1">&#39;Practice 1&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weekend</span></div>


<span class="k">def</span> <span class="nf">get_round</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get event number by year and (partial) event name</span>

<span class="sd">    A fuzzy match is performed to find the most likely event for the provided name.</span>

<span class="sd">    Args:</span>
<span class="sd">        year (int): Year of the event</span>
<span class="sd">        match (string): Name of the race or gp (e.g. &#39;Bahrain&#39;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        The round number. (2019, &#39;Bahrain&#39;) -&gt; 2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">build_string</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;https://en.wikipedia.org/wiki/&#39;</span><span class="p">)</span>  <span class="c1"># TODO what the hell is this</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Circuit&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Circuit&#39;</span><span class="p">][</span><span class="s1">&#39;Location&#39;</span><span class="p">]</span>  <span class="c1"># noqa: E741 (for now...)</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;url&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">:]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;raceName&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;circuitId&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;url&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">:]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;circuitName&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;locality&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;country&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">races</span> <span class="o">=</span> <span class="n">ergast</span><span class="o">.</span><span class="n">fetch_season</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
    <span class="n">to_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_string</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">races</span><span class="p">]</span>
    <span class="n">ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fuzz</span><span class="o">.</span><span class="n">partial_ratio</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">to_match</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">races</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ratios</span><span class="p">)][</span><span class="s1">&#39;round&#39;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_get_testing_week_event</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the correct weekend and event for testing from the</span>
<span class="sd">    year and day of the test. (where day is 1, 2, 3, ...)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">year</span> <span class="o">==</span> <span class="mi">2020</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">day</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">day</span><span class="p">)</span>
            <span class="n">week</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">day</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="k">else</span> <span class="mi">2</span>
        <span class="k">except</span><span class="p">:</span>  <span class="c1"># noqa: E722 TODO: improve</span>
            <span class="k">raise</span> <span class="n">InvalidSessionError</span>
        <span class="n">week_day</span> <span class="o">=</span> <span class="p">((</span><span class="n">day</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">pre_season_week</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Pre-Season Test </span><span class="si">{</span><span class="n">week</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">event</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Practice </span><span class="si">{</span><span class="n">week_day</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">year</span> <span class="o">==</span> <span class="mi">2021</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">day</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">pre_season_week</span> <span class="o">=</span> <span class="s1">&#39;Pre-Season Test&#39;</span>
        <span class="n">event</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Practice </span><span class="si">{</span><span class="n">day</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidSessionError</span>

    <span class="k">return</span> <span class="n">pre_season_week</span><span class="p">,</span> <span class="n">event</span>


<div class="viewcode-block" id="Telemetry"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry">[docs]</a><span class="k">class</span> <span class="nc">Telemetry</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multi-channel time series telemetry data</span>

<span class="sd">    The object can contain multiple telemetry channels. Multiple telemetry objects with different channels</span>
<span class="sd">    can be merged on time. Each telemetry channel is one dataframe column.</span>
<span class="sd">    Partial telemetry (e.g. for one lap only) can be obtained through various methods for slicing the data.</span>
<span class="sd">    Additionally, methods for adding common computed data channels are available.</span>

<span class="sd">    The following telemetry channels existed in the original API data:</span>

<span class="sd">        - **Car data**:</span>
<span class="sd">            - `Speed` (float): Car speed</span>
<span class="sd">            - `RPM` (int): Car RPM</span>
<span class="sd">            - `nGear` (int): Car gear number</span>
<span class="sd">            - `Throttle` (float): 0-100 Throttle pedal pressure</span>
<span class="sd">            - `Brake` (float): 0-100 Brake pedal pressure</span>
<span class="sd">            - `DRS` (int): DRS indicator</span>

<span class="sd">        - **Position data**:</span>
<span class="sd">            - `X` (float): X position</span>
<span class="sd">            - `Y` (float): Y position</span>
<span class="sd">            - `Z` (float): Z position</span>
<span class="sd">            - `Status` (string): Flag - OffTrack/OnTrack</span>

<span class="sd">        - **For both of the above**:</span>
<span class="sd">            - `Time` (timedelta): Time (0 is start of the data slice)</span>
<span class="sd">            - `SessionTime` (timedelta): Time elapsed since the start of the session</span>
<span class="sd">            - `Date` (datetime): The full date + time at which this sample was created</span>
<span class="sd">            - `Source` (str): Flag indicating how this sample was created:</span>

<span class="sd">                - &#39;car&#39;: sample from original api car data</span>
<span class="sd">                - &#39;pos&#39;: sample from original api position data</span>
<span class="sd">                - &#39;interpolated&#39;: this sample was artificially created; all values are computed/interpolated</span>

<span class="sd">                Example:</span>
<span class="sd">                    A sample&#39;s source is indicated as &#39;car&#39;. It contains</span>
<span class="sd">                    values for speed, rpm and x, y, z coordinates.</span>
<span class="sd">                    Originally, this sample (with its timestamp) was received</span>
<span class="sd">                    when loading car data.</span>
<span class="sd">                    This means that the speed and rpm value are original</span>
<span class="sd">                    values as received from the api. The coordinates are</span>
<span class="sd">                    interpolated for this sample.</span>

<span class="sd">                    All methods of :class:`Telemetry` which resample or</span>
<span class="sd">                    interpolate data will preserve and adjust the source flag</span>
<span class="sd">                    correctly when modifying data.</span>

<span class="sd">        Through merging/slicing it is possible to obtain any combination of telemetry channels!</span>
<span class="sd">        The following additional computed data channels can be added:</span>

<span class="sd">            - Distance driven between two samples:</span>
<span class="sd">              :meth:`add_differential_distance`</span>
<span class="sd">            - Distance driven since the first sample:</span>
<span class="sd">              :meth:`add_distance`</span>
<span class="sd">            - Relative distance driven since the first sample:</span>
<span class="sd">              :meth:`add_relative_distance`</span>
<span class="sd">            - Distance to driver ahead and car number of said driver:</span>
<span class="sd">              :meth:`add_driver_ahead`</span>

<span class="sd">        .. note:: See the separate explanation concerning the various definitions of &#39;Time&#39; for more information on the</span>
<span class="sd">          three date and time related channels: :ref:`time-explanation`</span>

<span class="sd">    Slicing this class will return :class:`Telemetry` again for slices containing multiple rows. Single rows will be</span>
<span class="sd">    returned as :class:`pandas.Series`.</span>

<span class="sd">    Args:</span>
<span class="sd">        *args (any): passed through to `pandas.DataFrame` superclass</span>
<span class="sd">        session (:class:`Session`): Instance of associated session object. Required for full functionality!</span>
<span class="sd">        driver (str): Driver number as string. Required for full functionality!</span>
<span class="sd">        **kwargs (any): passed through to `pandas.DataFrame` superclass</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TELEMETRY_FREQUENCY</span> <span class="o">=</span> <span class="s1">&#39;original&#39;</span>
    <span class="sd">&quot;&quot;&quot;Defines the frequency used when resampling the telemetry data. Either</span>
<span class="sd">    the string ``&#39;original&#39;`` or an integer to specify a frequency in Hz.&quot;&quot;&quot;</span>

    <span class="n">_CHANNELS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Status&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Speed&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">},</span>     <span class="c1"># linear is often required as quadratic overshoots</span>
        <span class="s1">&#39;RPM&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">},</span>       <span class="c1"># on sudden changes like sudden pedal application,</span>
        <span class="s1">&#39;Throttle&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">},</span>  <span class="c1"># braking, ...)</span>
        <span class="s1">&#39;Brake&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">},</span>
        <span class="s1">&#39;DRS&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;nGear&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Source&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;excluded&#39;</span><span class="p">},</span>  <span class="c1"># special case, custom handling</span>
        <span class="s1">&#39;Date&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;excluded&#39;</span><span class="p">},</span>  <span class="c1"># special case, used as the index during resampling</span>
        <span class="s1">&#39;Time&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;excluded&#39;</span><span class="p">},</span>  <span class="c1"># special case, Time/SessionTime recalculated from &#39;Date&#39;</span>
        <span class="s1">&#39;SessionTime&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;excluded&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Distance&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;RelativeDistance&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;DifferentialDistance&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;DriverAhead&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="sd">&quot;&quot;&quot;Known telemetry channels which are supported by default&quot;&quot;&quot;</span>

    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;driver&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Telemetry</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_class_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a nicer debugging experience; can view DataFrame through this property in various IDEs&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Telemetry.join"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wraps :mod:`pandas.DataFrame.join` and adds metadata propagation.</span>

<span class="sd">        When calling `self.join` metadata will be propagated from self to the joined dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Telemetry.merge"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wraps :mod:`pandas.DataFrame.merge` and adds metadata propagation.</span>

<span class="sd">        When calling `self.merge` metadata will be propagated from self to the merged dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Telemetry.slice_by_mask"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.slice_by_mask">[docs]</a>    <span class="k">def</span> <span class="nf">slice_by_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice self using a boolean array as a mask.</span>

<span class="sd">        Args:</span>
<span class="sd">            mask (array-like): Array of boolean values with the same length as self</span>
<span class="sd">            pad (int): Number of samples used for padding the sliced data</span>
<span class="sd">            pad_side (str): Where to pad the data; possible options: &#39;both&#39;, &#39;before&#39;, &#39;after&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pad_side</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;before&#39;</span><span class="p">):</span>
                <span class="n">i_left_pad</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span> <span class="o">-</span> <span class="n">pad</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_left_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">pad_side</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;after&#39;</span><span class="p">):</span>
                <span class="n">i_right_pad</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span> <span class="o">+</span> <span class="n">pad</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_right_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i_left_pad</span><span class="p">:</span> <span class="n">i_right_pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">data_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">data_slice</span></div>

<div class="viewcode-block" id="Telemetry.slice_by_lap"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.slice_by_lap">[docs]</a>    <span class="k">def</span> <span class="nf">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_laps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">interpolate_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice self to only include data from the provided lap or laps.</span>

<span class="sd">        .. note:: Self needs to contain a &#39;SessionTime&#39; column.</span>

<span class="sd">        .. note:: When slicing with an instance of :class:`Laps` as a reference, the data will be sliced by first and</span>
<span class="sd">            last lap. Missing laps in between will not be considered and data for these will still be included in</span>
<span class="sd">            the sliced result.</span>

<span class="sd">        Args:</span>
<span class="sd">            ref_laps (Lap or Laps): The lap/laps by which to slice self</span>
<span class="sd">            pad (int): Number of samples used for padding the sliced data</span>
<span class="sd">            pad_side (str): Where to pad the data; possible options: &#39;both&#39;, &#39;before&#39;, &#39;after</span>
<span class="sd">            interpolate_edges (bool): Add an interpolated sample at the beginning and end to exactly</span>
<span class="sd">                match the provided time window.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">,</span> <span class="n">Laps</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;DriverNumber&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_laps</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Laps is missing &#39;DriverNumber&#39;. Cannot return telemetry for unknown driver.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot create telemetry for multiple drivers at once!&quot;</span><span class="p">)</span>

            <span class="n">end_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">,</span> <span class="p">(</span><span class="n">Lap</span><span class="p">,</span> <span class="n">Laps</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">,</span> <span class="n">Laps</span><span class="p">):</span>  <span class="c1"># one lap in Laps</span>
                <span class="n">ref_laps</span> <span class="o">=</span> <span class="n">ref_laps</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># needs to be handled as a single lap</span>
            <span class="k">if</span> <span class="s1">&#39;DriverNumber&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_laps</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lap is missing &#39;DriverNumber&#39;. Cannot return telemetry for unknown driver.&quot;</span><span class="p">)</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Attribute &#39;ref_laps&#39; needs to be an instance of `Lap` or `Laps`&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_by_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pad_side</span><span class="p">,</span> <span class="n">interpolate_edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.slice_by_time"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.slice_by_time">[docs]</a>    <span class="k">def</span> <span class="nf">slice_by_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">interpolate_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice self to only include data in a specific time frame.</span>

<span class="sd">        .. note:: Self needs to contain a &#39;SessionTime&#39; column. Slicing by time use the &#39;SessionTime&#39; as its reference.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_time (Timedelta): Start of the section</span>
<span class="sd">            end_time (Timedelta): End of the section</span>
<span class="sd">            pad (int): Number of samples used for padding the sliced data</span>
<span class="sd">            pad_side (str): Where to pad the data; possible options: &#39;both&#39;, &#39;before&#39;, &#39;after</span>
<span class="sd">            interpolate_edges (bool): Add an interpolated sample at the beginning and end to exactly</span>
<span class="sd">                match the provided time window.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interpolate_edges</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">({</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">),</span>
                               <span class="s1">&#39;Date&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">start_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span><span class="p">,</span> <span class="n">end_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span><span class="p">)},</span>
                              <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># TODO no copy?</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sel</span><span class="p">):</span>
            <span class="n">data_slice</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">slice_by_mask</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pad_side</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;Time&#39;</span> <span class="ow">in</span> <span class="n">data_slice</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># shift time to 0 so laps can overlap</span>
                <span class="n">data_slice</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_slice</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_time</span>

            <span class="k">return</span> <span class="n">data_slice</span>
        <span class="k">return</span> <span class="n">Telemetry</span><span class="p">()</span></div>

<div class="viewcode-block" id="Telemetry.merge_channels"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.merge_channels">[docs]</a>    <span class="k">def</span> <span class="nf">merge_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge telemetry objects containing different telemetry channels.</span>

<span class="sd">        The two objects don&#39;t need to have a common time base. The data will be merged, optionally resampled and</span>
<span class="sd">        missing values will be interpolated.</span>

<span class="sd">        :attr:`Telemetry.TELEMETRY_FREQUENCY` determines if and how the data is resampled. This can be overridden using</span>
<span class="sd">        the `frequency` keyword fo this method.</span>

<span class="sd">        Merging and resampling:</span>

<span class="sd">            If the frequency is &#39;original&#39;, data will not be resampled. The two objects will be merged and all</span>
<span class="sd">            timestamps of both objects are kept. Values will be interpolated so that all telemetry channels contain</span>
<span class="sd">            valid data for all timestamps. This is the default and recommended option.</span>

<span class="sd">            If the frequency is specified as an integer in Hz the data will be merged as before. After that, the merged</span>
<span class="sd">            time base will be resampled from the first value on at the specified frequency. Afterwards, the data will</span>
<span class="sd">            be interpolated to fit the new time base. This means that usually most if not all values of the data will</span>
<span class="sd">            be interpolated values. This is detrimental for overall accuracy.</span>

<span class="sd">        Interpolation:</span>

<span class="sd">            Missing values after merging will be interpolated for all known telemetry channels using</span>
<span class="sd">            :meth:`fill_missing`. Different interpolation methods are used depending on what kind of data the channel</span>
<span class="sd">            contains. For example, forward fill is used to interpolated &#39;nGear&#39; while linear interpolation is used</span>
<span class="sd">            for &#39;RPM&#39; interpolation.</span>

<span class="sd">        .. note :: Unknown telemetry channels will be merged but missing values will not be interpolated. This can</span>
<span class="sd">            either be done manually or a custom telemetry channel can be added using :meth:`register_new_channel`.</span>

<span class="sd">        .. note :: Do not resample data multiple times. Always resample based on the original data</span>
<span class="sd">            to preserve accuracy</span>

<span class="sd">        Args:</span>
<span class="sd">            other (:class:`Telemetry` or :class:`pandas.DataFrame`): Object to be merged with self</span>
<span class="sd">            frequency (str or int): Optional frequency to overwrite global preset. (Either string &#39;original&#39; or integer</span>
<span class="sd">                for a frequency in Hz)</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># merge the data and interpolate missing; &#39;Date&#39; needs to be the index</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">)</span>

        <span class="c1"># save dtypes before merging so they can be restored after merging</span>
        <span class="c1"># necessary for example because merging produces NaN values which would cause an int column to become float</span>
        <span class="c1"># but it can be converted back to int after interpolating missing values</span>
        <span class="n">dtype_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dtype_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">dtype_map</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Exclude columns existing on both dataframes from one dataframe before merging (cannot merge with duplicates)</span>
        <span class="n">on_both_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">on_both_columns</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)],</span>
                             <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># now use the previously excluded columns to update the missing values in the merged dataframe</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">on_both_columns</span><span class="p">:</span>
            <span class="n">merged</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>

        <span class="k">if</span> <span class="s1">&#39;Driver&#39;</span> <span class="ow">in</span> <span class="n">merged</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge multiple drivers&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">frequency</span><span class="p">:</span>
            <span class="n">frequency</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">TELEMETRY_FREQUENCY</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_first_non_zero_time_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid &#39;Time&#39; data. Cannot resample!&quot;</span><span class="p">)</span>

        <span class="n">ref_date</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># data needs to be resampled/interpolated differently, depending on what kind of data it is</span>
        <span class="c1"># how to handle which column is defined in self._CHANNELS</span>

        <span class="k">if</span> <span class="n">frequency</span> <span class="o">==</span> <span class="s1">&#39;original&#39;</span><span class="p">:</span>
            <span class="c1"># no resampling but still interpolation due to merging</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">fill_missing</span><span class="p">()</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="s1">&#39;Date&#39;</span><span class="p">})</span>  <span class="c1"># make &#39;Date&#39; a column again</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">frq</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">1</span> <span class="o">/</span> <span class="n">frequency</span><span class="si">}</span><span class="s1">S&#39;</span>

            <span class="n">resampled_columns</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">sig_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">sig_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;missing&#39;</span><span class="p">]</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span> \
                        <span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">frq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">ref_date</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">sig_type</span> <span class="o">==</span> <span class="s1">&#39;discrete&#39;</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">frq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">ref_date</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span>
                    <span class="c1"># first ffill is a method of the resampler object and will ONLY ffill values created during</span>
                    <span class="c1"># resampling but not already existing NaN values. NaN values already existed because of merging,</span>
                    <span class="c1"># therefore call ffill a second time as a method of the returned series to fill these too</span>
                    <span class="c1"># only use bfill after ffill to fix first row</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">resampled_columns</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>

            <span class="n">res_source</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">frq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">ref_date</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;interpolation&#39;</span><span class="p">)</span>
            <span class="n">resampled_columns</span><span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_source</span>

            <span class="c1"># join resampled columns and make &#39;Date&#39; a column again</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">(</span><span class="n">resampled_columns</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="s1">&#39;Date&#39;</span><span class="p">})</span>

            <span class="c1"># recalculate the time columns</span>
            <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span>
            <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># restore data types from before merging</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">dtype_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_map</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to preserve data type for column &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; while merging telemetry.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged</span></div>

<div class="viewcode-block" id="Telemetry.resample_channels"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.resample_channels">[docs]</a>    <span class="k">def</span> <span class="nf">resample_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_date_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample telemetry data.</span>

<span class="sd">        Convenience method for frequency conversion and resampling. Up and down sampling of data is supported.</span>
<span class="sd">        &#39;Date&#39; and &#39;SessionTime&#39; need to exist in the data. &#39;Date&#39; is used as the main time reference.</span>

<span class="sd">        There are two ways to use this method:</span>

<span class="sd">            - Usage like :meth:`pandas.DataFrame.resample`: In this case you need to specify the &#39;rule&#39; for resampling</span>
<span class="sd">              and any additional keywords will be passed on to :meth:`pandas.Series.resample` to create a new time</span>
<span class="sd">              reference. See the pandas method to see which options are available.</span>

<span class="sd">            - using the &#39;new_date_ref&#39; keyword a :class:`pandas.Series` containing new values for date</span>
<span class="sd">              (dtype :class:`pandas.Timestamp`) can be provided. The existing data will be resampled onto this new</span>
<span class="sd">              time reference.</span>

<span class="sd">        Args:</span>
<span class="sd">            rule (optional, str): Resampling rule for :meth:`pandas.Series.resample`</span>
<span class="sd">            new_date_ref (optional, pandas.Series): New custom Series of reference dates</span>
<span class="sd">            **kwargs (optional, any): Only in combination with &#39;rule&#39;; additional parameters for</span>
<span class="sd">                :meth:`pandas.Series.resample`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_date_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You can only specify one of &#39;rule&#39; or &#39;new_index&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rule</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_date_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to specify either &#39;rule&#39; or &#39;new_index&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_date_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span>
            <span class="n">new_date_ref</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">new_tel</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">(</span><span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">new_tel</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_date_ref</span>

        <span class="n">combined_tel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">Telemetry</span><span class="p">({</span><span class="s1">&#39;Date&#39;</span><span class="p">:</span> <span class="n">new_date_ref</span><span class="p">},</span> <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">combined_tel</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">new_date_ref</span><span class="p">)</span>
        <span class="n">new_tel</span> <span class="o">=</span> <span class="n">combined_tel</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">new_tel</span></div>

<div class="viewcode-block" id="Telemetry.fill_missing"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.fill_missing">[docs]</a>    <span class="k">def</span> <span class="nf">fill_missing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate missing values in self.</span>

<span class="sd">        Only known telemetry channels will be interpolated. Unknown channels are skipped and returned unmodified.</span>
<span class="sd">        Interpolation will be done according to the default mapping and according to options specified for</span>
<span class="sd">        registered custom channels. For example:</span>
<span class="sd">        | Linear interpolation will be used for continuous values (Speed, RPM)</span>
<span class="sd">        | Forward-fill will be used for discrete values (Gear, DRS, ...)</span>

<span class="sd">        See :meth:`register_new_channel` for adding custom channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">sig_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sig_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>  <span class="c1"># yes, this is necessary to prevent pandas from crashing</span>
                <span class="k">if</span> <span class="n">ret</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Interpolation not possible for telemetry &quot;</span>
                                  <span class="s2">&quot;channel because dtype is &#39;object&#39;&quot;</span><span class="p">)</span>
                <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;missing&#39;</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span>\
                    <span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span> <span class="n">limit_direction</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">sig_type</span> <span class="o">==</span> <span class="s1">&#39;discrete&#39;</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span>
                <span class="c1"># first ffill is a method of the resampler object and will ONLY ffill values created during</span>
                <span class="c1"># resampling but not already existing NaN values. NaN values already existed because of merging,</span>
                <span class="c1"># therefore call ffill a second time as a method of the returned series to fill these too</span>
                <span class="c1"># only use bfill after ffill to fix first row</span>

        <span class="k">if</span> <span class="s1">&#39;Source&#39;</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;interpolation&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;Date&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span>  <span class="c1"># assume index is Date</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Telemetry.register_new_channel"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.register_new_channel">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">register_new_channel</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">signal_type</span><span class="p">,</span> <span class="n">interpolation_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a custom telemetry channel.</span>

<span class="sd">        Registered telemetry channels are automatically interpolated when merging or resampling data.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Telemetry channel/column name</span>
<span class="sd">            signal_type (str): One of three possible signal types:</span>
<span class="sd">                - &#39;continuous&#39;: Speed, RPM, Distance, ...</span>
<span class="sd">                - &#39;discrete&#39;: DRS, nGear, status values, ...</span>
<span class="sd">                - &#39;excluded&#39;: Data channel will be ignored during resampling</span>
<span class="sd">            interpolation_method (optional, str): The interpolation method</span>
<span class="sd">                which should be used. Can only be specified and is required</span>
<span class="sd">                in combination with ``signal_type=&#39;continuous&#39;``. See</span>
<span class="sd">                :meth:`pandas.Series.interpolate` for possible interpolation</span>
<span class="sd">                methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">signal_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;discrete&#39;</span><span class="p">,</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;excluded&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown signal type </span><span class="si">{</span><span class="n">signal_type</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">signal_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span> <span class="ow">and</span> <span class="n">interpolation_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;signal_type=&#39;continuous&#39; requires interpolation_method to be specified.&quot;</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">signal_type</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="n">interpolation_method</span><span class="p">}</span></div>

<div class="viewcode-block" id="Telemetry.get_first_non_zero_time_index"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.get_first_non_zero_time_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_first_non_zero_time_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the first index at which the &#39;Time&#39; value is not zero or NA/NaT&quot;&quot;&quot;</span>
        <span class="c1"># find first row where time is not zero; usually this is the first row but sometimes.....</span>
        <span class="n">i_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">i_arr</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Telemetry.add_differential_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.add_differential_distance">[docs]</a>    <span class="k">def</span> <span class="nf">add_differential_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drop_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add column &#39;DifferentialDistance&#39; to self.</span>

<span class="sd">        This column contains the distance driven between subsequent samples.</span>

<span class="sd">        Calls :meth:`calculate_differential_distance` and joins the result</span>
<span class="sd">        with self.</span>

<span class="sd">        Args:</span>
<span class="sd">            drop_existing (bool): Drop and recalculate column if it already exists</span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`: self joined with new column or self if column exists and `drop_existing` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;Distance&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_existing</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;DifferentialDistance&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>\
                    <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;DifferentialDistance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_differential_distance</span><span class="p">()}),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;DifferentialDistance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_differential_distance</span><span class="p">()}),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.add_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.add_distance">[docs]</a>    <span class="k">def</span> <span class="nf">add_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drop_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add column &#39;Distance&#39; to self.</span>

<span class="sd">        This column contains the distance driven since the first sample of self in meters.</span>

<span class="sd">        The data is produced by integrating the differential distance between subsequent laps.</span>
<span class="sd">        You should not apply this function to telemetry of many laps simultaneously to reduce integration error.</span>
<span class="sd">        Instead apply it only to single laps or few laps at a time!</span>

<span class="sd">        Calls :meth:`integrate_distance` and joins the result with self.</span>

<span class="sd">        Args:</span>
<span class="sd">            drop_existing (bool): Drop and recalculate column if it already exists</span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`: self joined with new column or self if column exists and `drop_existing` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;Distance&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_existing</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;Distance&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Distance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate_distance</span><span class="p">()}),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Distance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate_distance</span><span class="p">()}),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.add_relative_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.add_relative_distance">[docs]</a>    <span class="k">def</span> <span class="nf">add_relative_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drop_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add column &#39;RelativeDistance&#39; to self.</span>

<span class="sd">        This column contains the distance driven since the first sample as</span>
<span class="sd">        a floating point number where ``0.0`` is the first sample of self</span>
<span class="sd">        and ``1.0`` is the last sample.</span>

<span class="sd">        This is calculated the same way as &#39;Distance&#39; (see: :meth:`add_distance`). The same warnings apply.</span>

<span class="sd">        Args:</span>
<span class="sd">            drop_existing (bool): Drop and recalculate column if it already exists</span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`: self joined with new column or self if column exists and `drop_existing` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;RelativeDistance&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_existing</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;RelativeDistance&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="s1">&#39;Distance&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">rel_dist</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Distance&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">integrate_distance</span><span class="p">()</span>
            <span class="n">rel_dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">dist</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;RelativeDistance&#39;</span><span class="p">:</span> <span class="n">rel_dist</span><span class="p">}),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.add_driver_ahead"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.add_driver_ahead">[docs]</a>    <span class="k">def</span> <span class="nf">add_driver_ahead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drop_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add column &#39;DriverAhead&#39; and &#39;DistanceToDriverAhead&#39; to self.</span>

<span class="sd">        DriverAhead: Driver number of the driver ahead as string</span>
<span class="sd">        DistanceToDriverAhead: Distance to next car ahead in meters</span>

<span class="sd">        .. note:: Cars in the pit lane are currently not excluded from the data. They will show up when overtaken on</span>
<span class="sd">            pit straight even if they&#39;re not technically in front of the car. A fix for this is TBD with other</span>
<span class="sd">            improvements.</span>

<span class="sd">        This should only be applied to data of single laps or few laps at a time to reduce integration error.</span>
<span class="sd">        For longer time spans it should be applied per lap and the laps</span>
<span class="sd">        should be merged afterwards.</span>
<span class="sd">        If you absolutely need to apply it to a whole session, use the legacy implementation. Note that data of</span>
<span class="sd">        the legacy implementation will be considerably less smooth. (see :mod:`fastf1.legacy`)</span>

<span class="sd">        Calls :meth:`calculate_driver_ahead` and joins the result with self.</span>

<span class="sd">        Args:</span>
<span class="sd">            drop_existing (bool): Drop and recalculate column if it already exists</span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`: self joined with new column or self if column exists and `drop_existing` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;DriverAhead&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s1">&#39;DistanceToDriverAhead&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_existing</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;DriverAhead&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">drv_ahead</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_driver_ahead</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;DriverAhead&#39;</span><span class="p">:</span> <span class="n">drv_ahead</span><span class="p">,</span> <span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">:</span> <span class="n">dist</span><span class="p">}),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.calculate_differential_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.calculate_differential_distance">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_differential_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the distance between subsequent samples of self.</span>

<span class="sd">        Distance is in meters</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`pandas.Series`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Speed&#39;</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">)]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Telemetry does not contain required channels &#39;Time&#39; and &#39;Speed&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Speed&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">3.6</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="k">return</span> <span class="n">ds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">()</span></div>

<div class="viewcode-block" id="Telemetry.integrate_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.integrate_distance">[docs]</a>    <span class="k">def</span> <span class="nf">integrate_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the distance driven since the first sample of self.</span>

<span class="sd">        Distance is in meters. The data is produce by integration. Integration error will stack up when used for</span>
<span class="sd">        long slices of data. This should therefore only be used for data of single laps or few laps at a time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`pd.Series`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_differential_distance</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ds</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">()</span></div>

<div class="viewcode-block" id="Telemetry.calculate_driver_ahead"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.calculate_driver_ahead">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_driver_ahead</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate driver ahead and distance to driver ahead.</span>

<span class="sd">        Driver ahead: Driver number of the driver ahead as string</span>
<span class="sd">        Distance to driver ahead: Distance to the car ahead in meters</span>

<span class="sd">        .. note:: This gives a smoother/cleaner result than the legacy implementation but WILL introduce</span>
<span class="sd">            integration error when used over long distances (more than one or two laps may sometimes be considered</span>
<span class="sd">            a long distance). If in doubt, do sanity checks (against the legacy version or in another way).</span>

<span class="sd">        Returns:</span>
<span class="sd">            driver ahead (numpy.array), distance to driver ahead (numpy.array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_end</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">combined_distance</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Assume the following lap profile as a catch all for all drivers</span>
        <span class="c1">#</span>
        <span class="c1"># |------ Lap before ------|------ n Laps between ------|------ Lap after ------|</span>
        <span class="c1">#        ^                                                   ^</span>
        <span class="c1">#        t_start                                             t_end</span>
        <span class="c1"># Integration of the distance needs to start at the finish line so that there exists a common zero point</span>
        <span class="c1"># Therefore find the &quot;lap before&quot; which is the lap during which the telemetry slice starts and the &quot;lap after&quot;</span>
        <span class="c1"># where the telemetry slice ends</span>
        <span class="c1"># Integrate distance over all relevant laps and slice by t_start and t_end after to get the interesting</span>
        <span class="c1"># part only</span>
        <span class="n">own_laps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">]</span>
        <span class="n">first_lap_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">own_laps</span><span class="p">[</span><span class="n">own_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t_start</span><span class="p">])[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">drv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">drivers</span><span class="p">:</span>
            <span class="c1"># find correct first relevant lap; very important for correct zero point in distance</span>
            <span class="n">drv_laps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">drv</span><span class="p">]</span>
            <span class="n">drv_laps_before</span> <span class="o">=</span> <span class="n">drv_laps</span><span class="p">[(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t_start</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">drv_laps_before</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">lap_n_before</span> <span class="o">=</span> <span class="n">drv_laps_before</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">lap_n_before</span> <span class="o">&lt;</span> <span class="n">first_lap_number</span><span class="p">:</span>
                    <span class="c1"># driver is behind on track an therefore will cross the finish line AFTER self</span>
                    <span class="c1"># therefore above check for LapStartTime &lt;= t_start is wrong</span>
                    <span class="c1"># the first relevant lap is the first lap with LapStartTime &gt; t_start which is lap_n_before += 1</span>
                    <span class="n">lap_n_before</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lap_n_before</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">])</span>

            <span class="c1"># find last relevant lap so as to no do too much unnecessary calculation later</span>
            <span class="n">drv_laps_after</span> <span class="o">=</span> <span class="n">drv_laps</span><span class="p">[</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t_end</span><span class="p">]</span>
            <span class="n">lap_n_after</span> <span class="o">=</span> <span class="n">drv_laps_after</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> \
                <span class="k">if</span> <span class="ow">not</span> <span class="n">drv_laps_after</span><span class="o">.</span><span class="n">empty</span> \
                <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">])</span>
            <span class="n">relevant_laps</span> <span class="o">=</span> <span class="n">drv_laps</span><span class="p">[(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lap_n_before</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lap_n_after</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">relevant_laps</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># first slice by lap and calculate distance, so that distance is zero at finish line</span>
            <span class="n">drv_tel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">car_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="n">relevant_laps</span><span class="p">)</span><span class="o">.</span><span class="n">add_distance</span><span class="p">()</span> \
                <span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">,</span> <span class="s1">&#39;Distance&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Distance&#39;</span><span class="p">:</span> <span class="n">drv</span><span class="p">})</span>

            <span class="c1"># now slice again by time to only get the relevant time frame</span>
            <span class="n">drv_tel</span> <span class="o">=</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">slice_by_time</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">drv_tel</span> <span class="o">=</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">)</span>
            <span class="n">combined_distance</span> <span class="o">=</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">drv_tel</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>

        <span class="c1"># create driver map for array</span>
        <span class="n">drv_map</span> <span class="o">=</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">own_dst</span> <span class="o">=</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">other_dst</span> <span class="o">=</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># replace distance with nan if it does not change</span>
        <span class="c1"># prepend first row before diff so that array size stays the same; but missing first sample because of that</span>
        <span class="n">other_dst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">other_dst</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">other_dst</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># resize own_dst to match shape of other_dst for easy subtraction</span>
        <span class="n">own_dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">own_dst</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">other_dst</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">delta_dst</span> <span class="o">=</span> <span class="n">other_dst</span> <span class="o">-</span> <span class="n">own_dst</span>
        <span class="n">delta_dst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">delta_dst</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># substitute nan with inf, else nan is returned as min</span>
        <span class="n">delta_dst</span><span class="p">[</span><span class="n">delta_dst</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># remove cars behind so that neg numbers are not returned as min</span>

        <span class="n">index_ahead</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">delta_dst</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">drv_ahead</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">drv_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_ahead</span><span class="p">])</span>
        <span class="n">drv_ahead</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">delta_dst</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># remove driver from all inf rows</span>

        <span class="n">dist_to_drv_ahead</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delta_dst</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">index_ahead</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_ahead</span><span class="p">))])</span>
        <span class="n">dist_to_drv_ahead</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">delta_dst</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># remove value from all inf rows</span>

        <span class="k">return</span> <span class="n">drv_ahead</span><span class="p">,</span> <span class="n">dist_to_drv_ahead</span></div></div>


<div class="viewcode-block" id="Weekend"><a class="viewcode-back" href="../../core.html#fastf1.Weekend">[docs]</a><span class="k">class</span> <span class="nc">Weekend</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Object for accessing weekend specific data.</span>

<span class="sd">    If you want to handle multiple sessions from the same race event you can use a :class:Weekend instance.</span>

<span class="sd">    For example you could do the following::</span>

<span class="sd">        import fastf1 as ff1</span>

<span class="sd">        weekend = ff1.get_session(2019, &#39;Monza&#39;)</span>
<span class="sd">        quali = weekend.get_quali() # Q Session</span>
<span class="sd">        race = weekend.get_race() # R Session</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">gp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gp</span> <span class="o">=</span> <span class="n">gp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_testing</span><span class="p">():</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The Ergast API is not supported for testing&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">year</span> <span class="o">==</span> <span class="mi">2020</span><span class="p">:</span>
                <span class="n">date</span> <span class="o">=</span> <span class="n">TESTING_LOOKUP</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)][</span><span class="nb">int</span><span class="p">(</span><span class="n">gp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">year</span> <span class="o">==</span> <span class="mi">2021</span><span class="p">:</span>
                <span class="n">date</span> <span class="o">=</span> <span class="n">TESTING_LOOKUP</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)][</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidSessionError</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;raceName&#39;</span><span class="p">:</span> <span class="n">gp</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="n">date</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ergast</span><span class="o">.</span><span class="n">fetch_weekend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exception</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Failed to load critical data from Ergast!</span><span class="se">\n\n</span><span class="s2"> Cannot determine the date and name &quot;</span>
                                 <span class="s2">&quot;of the event. Cannot proceed!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># TODO some backup strategy for this</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exception</span><span class="p">))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exception</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>

<div class="viewcode-block" id="Weekend.get_practice"><a class="viewcode-back" href="../../core.html#fastf1.Weekend.get_practice">[docs]</a>    <span class="k">def</span> <span class="nf">get_practice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the specified practice session.</span>
<span class="sd">        Args:</span>
<span class="sd">            number: 1, 2 or 3 - Free practice session number</span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`Session` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Practice </span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Weekend.get_quali"><a class="viewcode-back" href="../../core.html#fastf1.Weekend.get_quali">[docs]</a>    <span class="k">def</span> <span class="nf">get_quali</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the qualifying session.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Session` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Qualifying&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Weekend.get_race"><a class="viewcode-back" href="../../core.html#fastf1.Weekend.get_race">[docs]</a>    <span class="k">def</span> <span class="nf">get_race</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the race session.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Session` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Race&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Weekend.is_testing"><a class="viewcode-back" href="../../core.html#fastf1.Weekend.is_testing">[docs]</a>    <span class="k">def</span> <span class="nf">is_testing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Indicates whether this &#39;weekend&#39; is a testing event. (In which case is usually is not an actual weekend.)</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Test&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Weekend name, e.g. &quot;British Grand Prix&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;raceName&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">date</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Weekend race date (YYYY-MM-DD)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Session"><a class="viewcode-back" href="../../core.html#fastf1.Session">[docs]</a><span class="k">class</span> <span class="nc">Session</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Object for accessing session specific data.</span>

<span class="sd">    The session class will usually be your starting point. This object will have various information about</span>
<span class="sd">    the session such as `name` and `date`. To get the session&#39;s laps use :meth:`Session.load_laps`.</span>

<span class="sd">    .. note:: For full functionality lap and telemetry data need to be loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weekend</span><span class="p">,</span> <span class="n">session_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weekend</span> <span class="o">=</span> <span class="n">weekend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">session_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_session_date</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">api_path</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">make_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">date</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">is_testing</span><span class="p">():</span>
            <span class="c1"># The Ergast API can provide some general information about weekends, drivers, ...</span>
            <span class="c1"># See ergast.com</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">ergast</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="c1"># Ergast will take some time after a session until the data is available</span>
                <span class="c1"># while the data is not yet available, an error will be raised</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Ergast API lookup failed. The session is very recent and not yet available or does &quot;</span>
                                <span class="s2">&quot;not exist.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_empty_ergast_result</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exception</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to load data from Ergast API!&quot;</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">exception</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_empty_ergast_result</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_empty_ergast_result</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">laps</span> <span class="o">=</span> <span class="n">Laps</span><span class="p">(</span><span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Instance of :class:`Laps` containing all laps from all drivers in this session.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0_date</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># can only be set when/if telemetry has been downloaded</span>
        <span class="sd">&quot;&quot;&quot;Date timestamp which marks the beginning of the data stream.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session_start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Session time at which the session was started.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">car_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of car telemetry (Speed, RPM, etc.) as received from</span>
<span class="sd">        the api by car number (where car number is a string and the telemetry</span>
<span class="sd">        is an instance of :class:`Telemetry`)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of car position data as received from the api by car</span>
<span class="sd">        number (where car number is a string and the telemetry</span>
<span class="sd">        is an instance of :class:`Telemetry`)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;List of all drivers that took part in this session; contains driver numbers as string. Drivers for which</span>
<span class="sd">        lap or telemetry data is missing completely are not listed!&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_create_empty_ergast_result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;In case Ergast has no data, this function creates an empty result to emulate the structure.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">driver</span> <span class="ow">in</span> <span class="n">D_LOOKUP</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;number&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">driver</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="s1">&#39;Driver&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;code&#39;</span><span class="p">:</span> <span class="n">driver</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span>
                <span class="s1">&#39;Constructor&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">driver</span><span class="p">[</span><span class="mi">2</span><span class="p">]}})</span>

    <span class="k">def</span> <span class="nf">_get_session_date</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Session date formatted as &#39;%Y-%m-%d&#39; (e.g. &#39;2019-03-12&#39;)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">is_testing</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">:=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">year</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;2020&#39;</span><span class="p">:</span>
                <span class="n">week_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">day_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">date</span> <span class="o">=</span> <span class="n">TESTING_LOOKUP</span><span class="p">[</span><span class="n">year</span><span class="p">][</span><span class="n">week_index</span><span class="p">][</span><span class="n">day_index</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">year</span> <span class="o">==</span> <span class="s1">&#39;2021&#39;</span><span class="p">:</span>
                <span class="n">day_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">date</span> <span class="o">=</span> <span class="n">TESTING_LOOKUP</span><span class="p">[</span><span class="n">year</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">day_index</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Qualifying&#39;</span><span class="p">,</span> <span class="s1">&#39;Practice 3&#39;</span><span class="p">):</span>
            <span class="c1"># Assuming that quali was one day before race which is not always correct</span>
            <span class="c1"># TODO Should check if also formula1 makes this assumption</span>
            <span class="n">offset_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">date</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">offset_date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Practice 1&#39;</span><span class="p">,</span> <span class="s1">&#39;Practice 2&#39;</span><span class="p">):</span>
            <span class="c1"># Again, assuming that practice 1/2 are the day before quali (except Monaco)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Monaco Grand Prix&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">offset_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">date</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">offset_date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Race</span>
            <span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">date</span>

        <span class="k">return</span> <span class="n">date</span>

<div class="viewcode-block" id="Session.load_laps"><a class="viewcode-back" href="../../core.html#fastf1.Session.load_laps">[docs]</a>    <span class="k">def</span> <span class="nf">load_laps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_telemetry</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load lap timing information and telemetry data.</span>

<span class="sd">        This method creates a :class:`Laps` instance (:attr:`Session.laps`) which subclasses :class:`pandas.DataFrame`</span>
<span class="sd">        and contains information on a per lap basis. (The dataframe is additionally returned by this method.)</span>

<span class="sd">        The returned :class:`Laps` instance can be used just like a pandas DataFrame but offers some</span>
<span class="sd">        additional functionality.</span>

<span class="sd">        Downloading and parsing of the data takes a considerable amount of time. Therefore, it is highly recommended</span>
<span class="sd">        to enable caching so that most of the data processing needs to be done only once.</span>

<span class="sd">        .. note:: Absolute time is not super accurate. The moment a lap</span>
<span class="sd">            is logged is not always the same and there will be some</span>
<span class="sd">            jitter. At the moment lap time reference is synchronised</span>
<span class="sd">            on the sector time triggered with lowest latency.</span>
<span class="sd">            Expect an error of around ±10m when overlapping telemetry</span>
<span class="sd">            data of different laps.</span>

<span class="sd">        Args:</span>
<span class="sd">            with_telemetry (bool): Load telemetry data also.</span>
<span class="sd">                (Same as calling :meth:`Session.load_telemetry` manually)</span>
<span class="sd">            livedata (:class:`fastf1.livetiming.data.LiveTimingData`, optional) :</span>
<span class="sd">                instead of requesting the data from the api, locally saved</span>
<span class="sd">                livetiming data can be used as a data source</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weekend</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;From `timing_data` and `timing_app_data` a summary table is</span>
<span class="sd">        built. Lap by lap, information on tyre, sectors and times are</span>
<span class="sd">        organised in an accessible pandas data frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas dataframe</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">timing_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="n">app_data</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">timing_app_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="c1"># Now we do some manipulation to make it beautiful</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Processing timing data...&quot;</span><span class="p">)</span>

        <span class="c1"># Matching data and app_data. Not super straightforward</span>
        <span class="c1"># Sometimes a car may enter the pit without changing tyres, so</span>
        <span class="c1"># new compound is associated with the help of logging time.</span>
        <span class="n">useful</span> <span class="o">=</span> <span class="n">app_data</span><span class="p">[[</span><span class="s1">&#39;Driver&#39;</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Compound&#39;</span><span class="p">,</span> <span class="s1">&#39;TotalLaps&#39;</span><span class="p">,</span> <span class="s1">&#39;New&#39;</span><span class="p">]]</span>
        <span class="n">useful</span> <span class="o">=</span> <span class="n">useful</span><span class="p">[</span><span class="o">~</span><span class="n">useful</span><span class="p">[</span><span class="s1">&#39;Compound&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLapDataError</span>

        <span class="c1"># check when a session was started; for a race this indicates the start of the race</span>
        <span class="n">session_status</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">session_status_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span>
                                                 <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Started&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session_start_time</span> <span class="o">=</span> <span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">break</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">driver</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">):</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">driver</span><span class="p">]</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">useful</span><span class="p">[</span><span class="n">useful</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">driver</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># no data for this driver; skip</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="s1">&#39;Driver&#39;</span><span class="p">)</span>

            <span class="c1"># calculate lap start time by setting it to the &#39;Time&#39; of the previous lap</span>
            <span class="n">laps_start_time</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Race&#39;</span><span class="p">:</span>
                <span class="c1"># assumption that the first lap started when the session was started can only be made for the race</span>
                <span class="n">laps_start_time</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_start_time</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">laps_start_time</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">laps_start_time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">npit</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;NumberOfPitStops&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;NumberOfPitStops&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">npit</span>
                <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TotalLaps&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sel</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># check if df is defined already before concat (vars is a builtin function)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">result</span> <span class="k">if</span> <span class="s1">&#39;df&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">()</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">result</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># noqa: F821</span>

        <span class="n">laps</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># noqa: F821</span>
        <span class="n">laps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;TotalLaps&#39;</span><span class="p">:</span> <span class="s1">&#39;TyreLife&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;NumberOfPitStops&#39;</span><span class="p">:</span> <span class="s1">&#39;Stint&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Driver&#39;</span><span class="p">:</span> <span class="s1">&#39;DriverNumber&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;NumberOfLaps&#39;</span><span class="p">:</span> <span class="s1">&#39;LapNumber&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;New&#39;</span><span class="p">:</span> <span class="s1">&#39;FreshTyre&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># counting stints from 1</span>
        <span class="n">t_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">]:</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;Constructor&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">}</span>
        <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Team&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">t_map</span><span class="p">)</span>
        <span class="n">d_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">]:</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">][</span><span class="s1">&#39;code&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">}</span>
        <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">d_map</span><span class="p">)</span>
        <span class="c1"># add track status data</span>
        <span class="n">ts_data</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">track_status_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>

        <span class="k">def</span> <span class="nf">applicator</span><span class="p">(</span><span class="n">new_status</span><span class="p">,</span> <span class="n">current_status</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">current_status</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">new_status</span>
            <span class="k">elif</span> <span class="n">new_status</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_status</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">current_status</span> <span class="o">+</span> <span class="n">new_status</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">current_status</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts_data</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ts_data</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">ts_data</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">next_t</span><span class="p">,</span> <span class="n">next_status</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ts_data</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="n">ts_data</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">status</span> <span class="o">!=</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="c1"># status change partially in lap partially outside</span>
                    <span class="n">sel</span> <span class="o">=</span> <span class="p">(((</span><span class="n">next_t</span> <span class="o">&gt;=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">))</span> <span class="o">|</span>
                           <span class="p">((</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">next_t</span><span class="p">)))</span>
                    <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">curr</span><span class="p">:</span> <span class="n">applicator</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># status change two times in one lap (e.g. short yellow flag)</span>
                    <span class="n">sel</span> <span class="o">=</span> <span class="p">((</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">next_t</span><span class="p">))</span>
                    <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">curr</span><span class="p">:</span> <span class="n">applicator</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">t</span> <span class="o">=</span> <span class="n">next_t</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">next_status</span>

            <span class="n">sel</span> <span class="o">=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span>
            <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">curr</span><span class="p">:</span> <span class="n">applicator</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Could not load any valid session status information!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">laps</span> <span class="o">=</span> <span class="n">Laps</span><span class="p">(</span><span class="n">laps</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_lap_accuracy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">with_telemetry</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_telemetry</span><span class="p">(</span><span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded data for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">)</span><span class="si">}</span><span class="s2"> drivers: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">laps</span></div>

    <span class="k">def</span> <span class="nf">_check_lap_accuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accuracy validation; simples yes/no validation</span>
<span class="sd">        Currently only relies on provided information which can&#39;t catch all problems&quot;&quot;&quot;</span>
        <span class="c1"># TODO: check for outliers in lap start position</span>
        <span class="c1"># self.laps[&#39;IsAccurate&#39;] = False  # default should be not accurate</span>
        <span class="k">for</span> <span class="n">drv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">:</span>
            <span class="n">is_accurate</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">prev_lap</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">integrity_errors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">lap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="c1"># require existence, non-existence and specific values for some variables</span>
                <span class="n">check_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;PitInTime&#39;</span><span class="p">])</span>
                           <span class="o">&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;PitOutTime&#39;</span><span class="p">])</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">))</span>  <span class="c1"># slightly paranoid, allow only green and yellow flag</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]))</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector1Time&#39;</span><span class="p">]))</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector2Time&#39;</span><span class="p">]))</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector3Time&#39;</span><span class="p">])))</span>

                <span class="k">if</span> <span class="n">check_1</span><span class="p">:</span>  <span class="c1"># only do check 2 if all necessary values for this check are even available</span>
                    <span class="c1"># sum of sector times should be almost equal to lap time (tolerance 3ms)</span>
                    <span class="n">check_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector1Time&#39;</span><span class="p">],</span> <span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector2Time&#39;</span><span class="p">],</span>
                                                  <span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector3Time&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">(),</span>
                                          <span class="n">lap</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">(),</span>
                                          <span class="n">atol</span><span class="o">=</span><span class="mf">0.003</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">check_2</span><span class="p">:</span>
                        <span class="n">integrity_errors</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">check_2</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># data not available means fail</span>

                <span class="k">if</span> <span class="n">prev_lap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># first lap after safety car often has timing issues (as do all laps under safety car)</span>
                    <span class="n">check_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">prev_lap</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;4&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">check_3</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># no previous lap, no SC error</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">check_1</span> <span class="ow">and</span> <span class="n">check_2</span> <span class="ow">and</span> <span class="n">check_3</span>
                <span class="n">is_accurate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">prev_lap</span> <span class="o">=</span> <span class="n">lap</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_accurate</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">drv</span><span class="p">,</span> <span class="s1">&#39;IsAccurate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_accurate</span>

            <span class="k">if</span> <span class="n">integrity_errors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Driver </span><span class="si">{</span><span class="n">drv</span><span class="si">:</span><span class="s2"> &gt;2</span><span class="si">}</span><span class="s2">: Lap timing integrity check failed for </span><span class="si">{</span><span class="n">integrity_errors</span><span class="si">}</span><span class="s2"> lap(s)&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Session.load_telemetry"><a class="viewcode-back" href="../../core.html#fastf1.Session.load_telemetry">[docs]</a>    <span class="k">def</span> <span class="nf">load_telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load telemetry data from API.</span>

<span class="sd">        The raw data is divided into car data (Speed, RPM, ...) and position data (coordinates, on/off track). For each</span>
<span class="sd">        of the two types an instance of :class:`Telemetry` is created per driver. The properties</span>
<span class="sd">        :attr:`Session.car_data` and :attr:`Session.pos_data` are dictionaries which hold the the `Telemetry` objects</span>
<span class="sd">        keyed by driver number.</span>

<span class="sd">        The telemetry data can either be accessed through the above mentioned attributes or conveniently on a per</span>
<span class="sd">        lap basis through :class:`Lap` and :class:`Laps`. See :class:`Telemetry` on how to work with the telemetry</span>
<span class="sd">        data.</span>

<span class="sd">        Note that this method additionally calculates :attr:`Session.t0_date` and adds a `LapStartDate` column to</span>
<span class="sd">        :attr:`Session.laps`.</span>

<span class="sd">        Args:</span>
<span class="sd">            livedata (:class:`fastf1.livetiming.data.LiveTimingData`, optional) :</span>
<span class="sd">                instead of requesting the data from the api, locally saved</span>
<span class="sd">                livetiming data can be used as a data source</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">car_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">position_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">car_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="c1"># self.drivers should only contain drivers which exist in all parts of the data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_t0_date</span><span class="p">(</span><span class="n">car_data</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">drv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">:</span>
            <span class="c1"># drop and recalculate time stamps based on &#39;Date&#39;, because &#39;Date&#39; has a higher resolution</span>
            <span class="n">drv_car</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">(</span><span class="n">car_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="n">drv</span><span class="p">)</span>
            <span class="n">drv_pos</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">(</span><span class="n">pos_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="n">drv</span><span class="p">)</span>

            <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span>
            <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span>

            <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0_date</span>  <span class="c1"># create proper continuous timestamps</span>
            <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0_date</span>
            <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>
            <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">car_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_car</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_pos</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartDate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0_date</span></div>

<div class="viewcode-block" id="Session.get_driver"><a class="viewcode-back" href="../../core.html#fastf1.Session.get_driver">[docs]</a>    <span class="k">def</span> <span class="nf">get_driver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a driver object which contains additional information about a driver.</span>

<span class="sd">        Args:</span>
<span class="sd">            identifier (str): driver&#39;s three letter identifier (for example &#39;VER&#39;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Driver`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">][</span><span class="s1">&#39;code&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Driver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_calculate_t0_date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">car_data</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the date timestamp at which data for this session is starting.</span>

<span class="sd">        This does not mark the start of a race (or other sessions). This marks the start of the data which is sometimes</span>
<span class="sd">        far before.</span>

<span class="sd">        This function sets :attr:`self.t0_date` which is an internally required offset for some calculations.</span>

<span class="sd">        The current assumption is that the latest date which can be calculated is correct. (Based on the timestamp with</span>
<span class="sd">        the least delay.)</span>

<span class="sd">        Args:</span>
<span class="sd">            car_data: Car telemetry; should contain all samples and only original ones</span>
<span class="sd">            pos_data: Car position data; should contain all samples and only original ones</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">date_offset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="p">(</span><span class="n">car_data</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">drv</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">new_offset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">drv</span><span class="p">][</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">drv</span><span class="p">][</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">date_offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_offset</span> <span class="o">&gt;</span> <span class="n">date_offset</span><span class="p">:</span>
                    <span class="n">date_offset</span> <span class="o">=</span> <span class="n">new_offset</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t0_date</span> <span class="o">=</span> <span class="n">date_offset</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Laps"><a class="viewcode-back" href="../../core.html#fastf1.Laps">[docs]</a><span class="k">class</span> <span class="nc">Laps</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object for accessing lap (timing) data of multiple laps.</span>

<span class="sd">    Args:</span>
<span class="sd">        *args (any): passed through to :class:`pandas.DataFrame` super class</span>
<span class="sd">        session (:class:`Session`): instance of session class; required for</span>
<span class="sd">          full functionality</span>
<span class="sd">        **kwargs (any): passed through to :class:`pandas.DataFrame`</span>
<span class="sd">          super class</span>

<span class="sd">    This class allows for easily picking specific laps from all laps in a session. It implements some additional</span>
<span class="sd">    functionality on top off the usual `pandas.DataFrame` functionality. Among others, the laps&#39; associated telemetry</span>
<span class="sd">    data can be accessed.</span>

<span class="sd">    If for example you want to get the fastest lap of Bottas you can narrow it down like this::</span>

<span class="sd">        import fastf1 as ff1</span>

<span class="sd">        laps = ff1.get_session(2019, &#39;Bahrain&#39;, &#39;Q&#39;).load_laps()</span>
<span class="sd">        best_bottas = laps.pick_driver(&#39;BOT&#39;).pick_fastest()</span>

<span class="sd">        print(best_bottas[&#39;LapTime&#39;])</span>
<span class="sd">        # Timedelta(&#39;0 days 00:01:28.256000&#39;)</span>

<span class="sd">    Slicing this class will return :class:`Laps` again for slices containing multiple rows. Single rows will be</span>
<span class="sd">    returned as :class:`Lap`.</span>

<span class="sd">    The following information is available per lap (one DataFrame column for each):</span>
<span class="sd">        - **Time** (pandas.Timedelta): Session time when the lap time was set (end of lap)</span>
<span class="sd">        - **Driver** (string): Three letter driver identifier</span>
<span class="sd">        - **DriverNumber** (str): Driver number</span>
<span class="sd">        - **LapTime** (pandas.Timedelta): Recorded lap time</span>
<span class="sd">        - **LapNumber** (int): Recorded lap number</span>
<span class="sd">        - **Stint** (int): Stint number</span>
<span class="sd">        - **PitOutTime** (pandas.Timedelta): Session time when car exited the pit</span>
<span class="sd">        - **PitInTime** (pandas.Timedelta): Session time when car entered the pit</span>
<span class="sd">        - **Sector1Time** (pandas.Timedelta): Sector 1 recorded time</span>
<span class="sd">        - **Sector2Time** (pandas.Timedelta): Sector 2 recorded time</span>
<span class="sd">        - **Sector3Time** (pandas.Timedelta): Sector 3 recorded time</span>
<span class="sd">        - **Sector1SessionTime** (pandas.Timedelta): Session time when the Sector 1 time was set</span>
<span class="sd">        - **Sector2SessionTime** (pandas.Timedelta): Session time when the Sector 2 time was set</span>
<span class="sd">        - **Sector3SessionTime** (pandas.Timedelta): Session time when the Sector 3 time was set</span>
<span class="sd">        - **SpeedI1** (float): Speedtrap sector 1</span>
<span class="sd">        - **SpeedI2** (float): Speedtrap sector 2</span>
<span class="sd">        - **SpeedFL** (float): Speedtrap at finish line</span>
<span class="sd">        - **SpeedST** (float): Speedtrap on longest straight (Not sure)</span>
<span class="sd">        - **Compound** (str): Tyre compound name: SOFT, MEDIUM ..</span>
<span class="sd">        - **TyreLife** (float): Laps driven on this tire (includes laps in other sessions for used sets of tires)</span>
<span class="sd">        - **FreshTyre** (bool): Tyre had TyreLife=0 at stint start, i.e. was a new tire</span>
<span class="sd">        - **Team** (str): Team name</span>
<span class="sd">        - **LapStartTime** (pandas.Timedelta): Session time at the start of the lap</span>
<span class="sd">        - **LapStartDate** (pandas.Timestamp): Timestamp at the start of the lap</span>
<span class="sd">        - **TrackStatus** (str): A string that contains track status numbers for all track status that occurred</span>
<span class="sd">          during this lap. The meaning of the track status numbers is explained in</span>
<span class="sd">          :func:`fastf1.api.track_status_data`. (Currently, track status data is only implemented per lap.</span>
<span class="sd">          If a finer resolution is desired, you need to directly use the data returned by</span>
<span class="sd">          :func:`fastf1.api.track_status_data`)  # TODO updated when implemented</span>
<span class="sd">        - **IsAccurate** (bool): If True, the lap has passed a basic accuracy check for timing data.</span>
<span class="sd">          This does not guarantee accuracy but laps marked as inaccurate need to be handled with</span>
<span class="sd">          caution. They might contain errors which can not be spotted easily.</span>
<span class="sd">          Laps need to satisfy the following criteria to be marked</span>
<span class="sd">          as accurate:</span>

<span class="sd">            - not an inlap or outlap</span>
<span class="sd">            - set under green or yellow flag (the api sometimes has issues</span>
<span class="sd">              with data from SC/VSC laps)</span>
<span class="sd">            - is not the first lap after a safety car period</span>
<span class="sd">              (issues with SC/VSC might still apear on the first lap</span>
<span class="sd">              after it has ended)</span>
<span class="sd">            - has a value for lap time and all sector times</span>
<span class="sd">            - the sum of the sector times matches the lap time</span>
<span class="sd">              (will be additionally logged as integrity error if not)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">]</span>

    <span class="n">QUICKLAP_THRESHOLD</span> <span class="o">=</span> <span class="mf">1.07</span>
    <span class="sd">&quot;&quot;&quot;Used to determine &#39;quick&#39; laps. Defaults to the 107% rule.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Laps</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this is effectively &#39;return Lap&#39; but I need to pass a reference to the session instance too</span>
        <span class="c1"># what this actually does is to dynamically subclass Lap with the new class being called Lap again,</span>
        <span class="c1"># additionally the class variable session is added</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;Lap&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">Lap</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;session&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_class_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a nicer debugging experience; can now view as</span>
<span class="sd">        dataframe in various IDEs&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Telemetry data for all laps in `self`</span>

<span class="sd">        This is a cached (!) property for :meth:`get_telemetry`. It will return the same value as `get_telemetry`</span>
<span class="sd">        but cache the result so that the involved processing is only done once.</span>

<span class="sd">        This is mainly provided for convenience and backwards compatibility.</span>

<span class="sd">        See :meth:`get_telemetry` for more information.</span>

<span class="sd">        .. note:: Telemetry can only be returned if `self` contains laps of one driver only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_telemetry</span><span class="p">()</span>

<div class="viewcode-block" id="Laps.get_telemetry"><a class="viewcode-back" href="../../core.html#fastf1.Laps.get_telemetry">[docs]</a>    <span class="k">def</span> <span class="nf">get_telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Telemetry data for all laps in `self`</span>

<span class="sd">        Telemetry data is the result of merging the returned data from :meth:`get_car_data` and :meth:`get_pos_data`.</span>
<span class="sd">        This means that telemetry data at least partially contains interpolated values! Telemetry data additionally</span>
<span class="sd">        already has computed channels added (e.g. Distance).</span>

<span class="sd">        This method is provided for convenience and compatibility reasons. But using it does usually not produce</span>
<span class="sd">        the most accurate possible result.</span>
<span class="sd">        It is recommended to use :meth:`get_car_data` or :meth:`get_pos_data` when possible. This is also faster if</span>
<span class="sd">        merging of car and position data is not necessary and if not all computed channels are needed.</span>

<span class="sd">        Resampling during merging is done according to the frequency set by :attr:`TELEMETRY_FREQUENCY`.</span>

<span class="sd">        .. note:: Telemetry can only be returned if `self` contains laps of one driver only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pos_data</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_car_data</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="n">car_data</span><span class="o">.</span><span class="n">add_distance</span><span class="p">()</span><span class="o">.</span><span class="n">add_relative_distance</span><span class="p">()</span><span class="o">.</span><span class="n">add_driver_ahead</span><span class="p">()</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">car_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolate_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Laps.get_car_data"><a class="viewcode-back" href="../../core.html#fastf1.Laps.get_car_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_car_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Car data for all laps in `self`</span>

<span class="sd">        Slices the car data in :attr:`Session.car_data` using this set of laps and returns the result.</span>

<span class="sd">        The data returned by this method does not contain computed telemetry channels. The can be added by calling the</span>
<span class="sd">        appropriate `add_*()` method on the returned telemetry object..</span>

<span class="sd">        .. note:: Car data can only be returned if `self` contains laps of one driver only.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Keyword arguments are passed to :meth:`Telemetry.slice_by_lap`</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">drv_num</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drv_num</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice telemetry because self contains no driver number!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drv_num</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice telemetry because self contains Laps of multiple drivers!&quot;</span><span class="p">)</span>
        <span class="n">drv_num</span> <span class="o">=</span> <span class="n">drv_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">car_data</span><span class="p">[</span><span class="n">drv_num</span><span class="p">]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">car_data</span></div>

<div class="viewcode-block" id="Laps.get_pos_data"><a class="viewcode-back" href="../../core.html#fastf1.Laps.get_pos_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_pos_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pos data for all laps in `self`</span>

<span class="sd">        Slices the position data in :attr:`Session.pos_data` using this set of laps and returns the result.</span>

<span class="sd">        .. note:: Position data can only be returned if `self` contains laps of one driver only.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Keyword arguments are passed to :meth:`Telemetry.slice_by_lap`</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">drv_num</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drv_num</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice telemetry because self contains no driver number!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drv_num</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice telemetry because self contains Laps of multiple drivers!&quot;</span><span class="p">)</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">pos_data</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos_data</span></div>

<div class="viewcode-block" id="Laps.pick_driver"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_driver">[docs]</a>    <span class="k">def</span> <span class="nf">pick_driver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return all laps of a specific driver in self based on the driver&#39;s three letters identifier or</span>
<span class="sd">        based on the driver number ::</span>

<span class="sd">            perez_laps = ff1.pick_driver(&#39;PER&#39;)</span>
<span class="sd">            bottas_laps = ff1.pick_driver(77)</span>
<span class="sd">            kimi_laps = ff1.pick_driver(&#39;RAI&#39;)</span>

<span class="sd">        Args:</span>
<span class="sd">            identifier (str or int): Driver abbreviation or number</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">identifier</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">]</span></div>

<div class="viewcode-block" id="Laps.pick_drivers"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_drivers">[docs]</a>    <span class="k">def</span> <span class="nf">pick_drivers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifiers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return all laps of the specified drivers in self based on the drivers&#39; three letters identifier</span>
<span class="sd">        or based on the driver number. This is the same as :meth:`Laps.pick_driver` but for multiple drivers at once. ::</span>

<span class="sd">            some_drivers_laps = ff1.pick_drivers([5, &#39;BOT&#39;, 7])</span>

<span class="sd">        Args:</span>
<span class="sd">            identifiers (iterable): Multiple driver abbreviations or driver numbers (can be mixed)</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">identifiers</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">identifiers</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>
        <span class="n">drv</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[(</span><span class="n">drv</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">|</span> <span class="n">num</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">numbers</span><span class="p">))]</span></div>

<div class="viewcode-block" id="Laps.pick_team"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_team">[docs]</a>    <span class="k">def</span> <span class="nf">pick_team</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return all laps of a specific team in self based on the team&#39;s name ::</span>

<span class="sd">            mercedes = ff1.pick_team(&#39;Mercedes&#39;)</span>
<span class="sd">            alfa_romeo = ff1.pick_team(&#39;Alfa Romeo&#39;)</span>

<span class="sd">        Have a look to :attr:`fastf1.plotting.TEAM_COLORS` for a quick reference on team names.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Team name</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Team&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="Laps.pick_teams"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_teams">[docs]</a>    <span class="k">def</span> <span class="nf">pick_teams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return all laps of the specified teams in self based on the teams&#39; name.</span>
<span class="sd">        This is the same as :meth:`Laps.pick_team` but for multiple teams at once. ::</span>

<span class="sd">            some_drivers_laps = ff1.pick_teams([&#39;Mercedes&#39;, &#39;Williams&#39;])</span>

<span class="sd">        Args:</span>
<span class="sd">            names (iterable): Multiple team names</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Team&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">names</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Laps.pick_fastest"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_fastest">[docs]</a>    <span class="k">def</span> <span class="nf">pick_fastest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return the lap with the fastest lap time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Lap`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lap</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># More laps, same time</span>
            <span class="n">lap</span> <span class="o">=</span> <span class="n">lap</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># take first clocked</span>

        <span class="k">return</span> <span class="n">lap</span></div>

<div class="viewcode-block" id="Laps.pick_quicklaps"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_quicklaps">[docs]</a>    <span class="k">def</span> <span class="nf">pick_quicklaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return laps with `LapTime` faster than a certain limit.</span>
<span class="sd">        By default the threshold is 107% of the best `LapTime` of all laps in self.</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold (optional, float): custom threshold coefficent</span>
<span class="sd">                (e.g. 1.05 for 105%)</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Laps</span><span class="o">.</span><span class="n">QUICKLAP_THRESHOLD</span>
        <span class="n">time_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="n">threshold</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">time_threshold</span><span class="p">]</span></div>

<div class="viewcode-block" id="Laps.pick_tyre"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_tyre">[docs]</a>    <span class="k">def</span> <span class="nf">pick_tyre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compound</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return all laps in self which were done on a specific compound.</span>

<span class="sd">        Args:</span>
<span class="sd">            compound (string): may be &quot;SOFT&quot;, &quot;MEDIUM&quot;, &quot;HARD&quot;, &quot;INTERMEDIATE&quot; or &quot;WET&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Compound&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">compound</span><span class="p">]</span></div>

<div class="viewcode-block" id="Laps.pick_track_status"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_track_status">[docs]</a>    <span class="k">def</span> <span class="nf">pick_track_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;equals&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return laps set under a specific track status.</span>

<span class="sd">        Args:</span>
<span class="sd">            status (str): The track status as a string, e.g. &#39;1&#39;</span>
<span class="sd">            how (str): one of &#39;equals&#39;/&#39;contains&#39;</span>
<span class="sd">                For example, if how=&#39;equals&#39;, status=&#39;2&#39; will only match &#39;2&#39;.</span>
<span class="sd">                If how=&#39;contains&#39;, status=&#39;2&#39; will also match &#39;267&#39; and similar</span>
<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;equals&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">status</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;contains&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value &#39;</span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&#39; for kwarg &#39;how&#39;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Laps.pick_wo_box"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_wo_box">[docs]</a>    <span class="k">def</span> <span class="nf">pick_wo_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select laps which are NOT in laps or out laps.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;PitInTime&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;PitOutTime&#39;</span><span class="p">])]</span></div>

<div class="viewcode-block" id="Laps.pick_accurate"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_accurate">[docs]</a>    <span class="k">def</span> <span class="nf">pick_accurate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select and return laps which pass the accuracy validation check (lap[&#39;IsAccurate&#39;] is True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;IsAccurate&#39;</span><span class="p">]]</span></div>

<div class="viewcode-block" id="Laps.iterlaps"><a class="viewcode-back" href="../../core.html#fastf1.Laps.iterlaps">[docs]</a>    <span class="k">def</span> <span class="nf">iterlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">require</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Iterator for iterating over all laps in self.</span>

<span class="sd">        This method wraps :meth:`pandas.DataFrame.iterrows`.</span>
<span class="sd">        It additionally provides the `require` keyword argument.</span>

<span class="sd">        Args:</span>
<span class="sd">             require (optional, iterable): Require is a list of column/telemetry channel names. All names listed in</span>
<span class="sd">               `require` must exist in the data and have a non-null value (tested with :func:`pandas.is_null`). The</span>
<span class="sd">               iterator only yields laps for which this is true. If require is left empty, the iterator will yield</span>
<span class="sd">               all laps.</span>
<span class="sd">        Yields:</span>
<span class="sd">            instance of :class:`Lap`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">lap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">require</span><span class="p">:</span>
                <span class="c1"># make sure that all required values even exist in the index</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lap</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">require</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">require</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">require</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lap</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">lap</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">require</span><span class="p">]):</span>
                    <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">index</span><span class="p">,</span> <span class="n">lap</span></div></div>


<div class="viewcode-block" id="Lap"><a class="viewcode-back" href="../../core.html#fastf1.Lap">[docs]</a><span class="k">class</span> <span class="nc">Lap</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object for accessing lap (timing) data of a single lap.</span>

<span class="sd">    This class wraps :class:`pandas.Series`. It provides extra functionality for accessing a lap&#39;s associated</span>
<span class="sd">    telemetry data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Lap</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Telemetry data for this lap</span>

<span class="sd">        This is a cached (!) property for :meth:`get_telemetry`. It will return the same value as `get_telemetry`</span>
<span class="sd">        but cache the result so that the involved processing is only done once.</span>

<span class="sd">        This is mainly provided for convenience and backwards compatibility.</span>

<span class="sd">        See :meth:`get_telemetry` for more information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_telemetry</span><span class="p">()</span>

<div class="viewcode-block" id="Lap.get_telemetry"><a class="viewcode-back" href="../../core.html#fastf1.Lap.get_telemetry">[docs]</a>    <span class="k">def</span> <span class="nf">get_telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Telemetry data for this lap</span>

<span class="sd">        Telemetry data is the result of merging the returned data from :meth:`get_car_data` and :meth:`get_pos_data`.</span>
<span class="sd">        This means that telemetry data at least partially contains interpolated values! Telemetry data additionally</span>
<span class="sd">        already has computed channels added (e.g. Distance).</span>

<span class="sd">        This method is provided for convenience and compatibility reasons. But using it does usually not produce</span>
<span class="sd">        the most accurate possible result.</span>
<span class="sd">        It is recommended to use :meth:`get_car_data` or :meth:`get_pos_data` when possible. This is also faster if</span>
<span class="sd">        merging of car and position data is not necessary and if not all computed channels are needed.</span>

<span class="sd">        Resampling during merging is done according to the frequency set by :attr:`TELEMETRY_FREQUENCY`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pos_data</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_car_data</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="n">car_data</span><span class="o">.</span><span class="n">add_distance</span><span class="p">()</span><span class="o">.</span><span class="n">add_relative_distance</span><span class="p">()</span><span class="o">.</span><span class="n">add_driver_ahead</span><span class="p">()</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">car_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolate_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lap.get_car_data"><a class="viewcode-back" href="../../core.html#fastf1.Lap.get_car_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_car_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Car data for this lap</span>

<span class="sd">        Slices the car data in :attr:`Session.car_data` using this lap and returns the result.</span>

<span class="sd">        The data returned by this method does not contain computed telemetry channels. The can be added by calling the</span>
<span class="sd">        appropriate `add_*()` method on the returned telemetry object.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Keyword arguments are passed to :meth:`Telemetry.slice_by_lap`</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">car_data</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">car_data</span></div>

<div class="viewcode-block" id="Lap.get_pos_data"><a class="viewcode-back" href="../../core.html#fastf1.Lap.get_pos_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_pos_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pos data for all laps in `self`</span>

<span class="sd">        Slices the position data in :attr:`Session.pos_data` using this lap and returns the result.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Keyword arguments are passed to :meth:`Telemetry.slice_by_lap`</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">pos_data</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos_data</span></div></div>


<div class="viewcode-block" id="Driver"><a class="viewcode-back" href="../../core.html#fastf1.Driver">[docs]</a><span class="k">class</span> <span class="nc">Driver</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Driver class that provides some information on drivers and their finishing results.</span>

<span class="sd">    see also :meth:`Session.get_driver`</span>

<span class="sd">    .. note:: Driver data is only available if the Ergast api lookup did not fail.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="sd">&quot;&quot;&quot;`Driver.info` contains some more info from the Ergast api&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">][</span><span class="s1">&#39;code&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dnf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if driver did not finish&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Lap&#39;</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;Finished&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grid position&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finishing position&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Driver first name&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">][</span><span class="s1">&#39;givenName&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">familyname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Driver family name&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">][</span><span class="s1">&#39;familyName&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">team</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Team name&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;Constructor&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="NoLapDataError"><a class="viewcode-back" href="../../core.html#fastf1.NoLapDataError">[docs]</a><span class="k">class</span> <span class="nc">NoLapDataError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised if the API request does not fail but there is no usable data after processing the result.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NoLapDataError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;Failed to load session because the API did not provide any usable data.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="InvalidSessionError"><a class="viewcode-back" href="../../core.html#fastf1.InvalidSessionError">[docs]</a><span class="k">class</span> <span class="nc">InvalidSessionError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised if no session for the specified event name, type and year</span>
<span class="sd">    can be found.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InvalidSessionError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="s2">&quot;No matching session can be found.&quot;</span>
        <span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, theOehrly.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>